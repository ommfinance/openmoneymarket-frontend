{"ast":null,"code":"import _asyncToGenerator from \"/Users/robimarkac/Development/openmoneymarket-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, DisconnectedDeviceDuringOperation, DisconnectedDevice, TransportError } from \"@ledgerhq/errors\";\nconst ledgerDevices = [{\n  vendorId: ledgerUSBVendorId\n}];\n\nconst isSupported = () => Promise.resolve(!!(global.navigator && global.navigator.hid));\n\nconst getHID = () => {\n  // $FlowFixMe\n  const {\n    hid\n  } = navigator;\n  if (!hid) throw new TransportError(\"navigator.hid is not supported\", \"HIDNotSupported\");\n  return hid;\n};\n\nfunction requestLedgerDevices() {\n  return _requestLedgerDevices.apply(this, arguments);\n}\n\nfunction _requestLedgerDevices() {\n  _requestLedgerDevices = _asyncToGenerator(function* () {\n    const device = yield getHID().requestDevice({\n      filters: ledgerDevices\n    });\n    if (Array.isArray(device)) return device;\n    return [device];\n  });\n  return _requestLedgerDevices.apply(this, arguments);\n}\n\nfunction getLedgerDevices() {\n  return _getLedgerDevices.apply(this, arguments);\n}\n\nfunction _getLedgerDevices() {\n  _getLedgerDevices = _asyncToGenerator(function* () {\n    const devices = yield getHID().getDevices();\n    return devices.filter(d => d.vendorId === ledgerUSBVendorId);\n  });\n  return _getLedgerDevices.apply(this, arguments);\n}\n\nfunction getFirstLedgerDevice() {\n  return _getFirstLedgerDevice.apply(this, arguments);\n}\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\n\n\nfunction _getFirstLedgerDevice() {\n  _getFirstLedgerDevice = _asyncToGenerator(function* () {\n    const existingDevices = yield getLedgerDevices();\n    if (existingDevices.length > 0) return existingDevices[0];\n    const devices = yield requestLedgerDevices();\n    return devices[0];\n  });\n  return _getFirstLedgerDevice.apply(this, arguments);\n}\n\nexport default class TransportWebHID extends Transport {\n  constructor(device) {\n    var _this;\n\n    super();\n    _this = this;\n    this.device = void 0;\n    this.deviceModel = void 0;\n    this.channel = Math.floor(Math.random() * 0xffff);\n    this.packetSize = 64;\n    this.inputs = [];\n    this.inputCallback = void 0;\n\n    this.read = () => {\n      if (this.inputs.length) {\n        return Promise.resolve(this.inputs.shift());\n      }\n\n      return new Promise(success => {\n        this.inputCallback = success;\n      });\n    };\n\n    this.onInputReport = e => {\n      const buffer = Buffer.from(e.data.buffer);\n\n      if (this.inputCallback) {\n        this.inputCallback(buffer);\n        this.inputCallback = null;\n      } else {\n        this.inputs.push(buffer);\n      }\n    };\n\n    this._disconnectEmitted = false;\n\n    this._emitDisconnect = e => {\n      if (this._disconnectEmitted) return;\n      this._disconnectEmitted = true;\n      this.emit(\"disconnect\", e);\n    };\n\n    this.exchange = apdu => this.exchangeAtomicImpl( /*#__PURE__*/_asyncToGenerator(function* () {\n      const {\n        channel,\n        packetSize\n      } = _this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n      const framing = hidFraming(channel, packetSize); // Write...\n\n      const blocks = framing.makeBlocks(apdu);\n\n      for (let i = 0; i < blocks.length; i++) {\n        yield _this.device.sendReport(0, blocks[i]);\n      } // Read...\n\n\n      let result;\n      let acc;\n\n      while (!(result = framing.getReducedResult(acc))) {\n        const buffer = yield _this.read();\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    })).catch(e => {\n      if (e && e.message && e.message.includes(\"write\")) {\n        this._emitDisconnect(e);\n\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n\n      throw e;\n    });\n\n    this.device = device;\n    this.deviceModel = identifyUSBProductId(device.productId);\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n\n\n  static request() {\n    return _asyncToGenerator(function* () {\n      const [device] = yield requestLedgerDevices();\n      return TransportWebHID.open(device);\n    })();\n  }\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n\n\n  static openConnected() {\n    return _asyncToGenerator(function* () {\n      const devices = yield getLedgerDevices();\n      if (devices.length === 0) return null;\n      return TransportWebHID.open(devices[0]);\n    })();\n  }\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n\n\n  static open(device) {\n    return _asyncToGenerator(function* () {\n      yield device.open();\n      const transport = new TransportWebHID(device);\n\n      const onDisconnect = e => {\n        if (device === e.device) {\n          getHID().removeEventListener(\"disconnect\", onDisconnect);\n\n          transport._emitDisconnect(new DisconnectedDevice());\n        }\n      };\n\n      getHID().addEventListener(\"disconnect\", onDisconnect);\n      return transport;\n    })();\n  }\n  /**\n   * Release the transport device\n   */\n\n\n  close() {\n    var _this2 = this;\n\n    return _asyncToGenerator(function* () {\n      yield _this2.exchangeBusyPromise;\n\n      _this2.device.removeEventListener(\"inputreport\", _this2.onInputReport);\n\n      yield _this2.device.close();\n    })();\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n\n  setScrambleKey() {}\n\n}\nTransportWebHID.isSupported = isSupported;\nTransportWebHID.list = getLedgerDevices;\n\nTransportWebHID.listen = observer => {\n  let unsubscribed = false;\n  getFirstLedgerDevice().then(device => {\n    if (!device) {\n      observer.error(new TransportOpenUserCancelled(\"Access denied to use Ledger device\"));\n    } else if (!unsubscribed) {\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device,\n        deviceModel\n      });\n      observer.complete();\n    }\n  }, error => {\n    observer.error(new TransportOpenUserCancelled(error.message));\n  });\n\n  function unsubscribe() {\n    unsubscribed = true;\n  }\n\n  return {\n    unsubscribe\n  };\n};","map":{"version":3,"sources":["/Users/robimarkac/Development/openmoneymarket-frontend/node_modules/@ledgerhq/hw-transport-webhid/lib-es/TransportWebHID.js"],"names":["Transport","hidFraming","identifyUSBProductId","ledgerUSBVendorId","log","TransportOpenUserCancelled","DisconnectedDeviceDuringOperation","DisconnectedDevice","TransportError","ledgerDevices","vendorId","isSupported","Promise","resolve","global","navigator","hid","getHID","requestLedgerDevices","device","requestDevice","filters","Array","isArray","getLedgerDevices","devices","getDevices","filter","d","getFirstLedgerDevice","existingDevices","length","TransportWebHID","constructor","deviceModel","channel","Math","floor","random","packetSize","inputs","inputCallback","read","shift","success","onInputReport","e","buffer","Buffer","from","data","push","_disconnectEmitted","_emitDisconnect","emit","exchange","apdu","exchangeAtomicImpl","toString","framing","blocks","makeBlocks","i","sendReport","result","acc","getReducedResult","reduceResponse","catch","message","includes","productId","addEventListener","request","open","openConnected","transport","onDisconnect","removeEventListener","close","exchangeBusyPromise","setScrambleKey","list","listen","observer","unsubscribed","then","error","next","type","descriptor","complete","unsubscribe"],"mappings":";AAAA,OAAOA,SAAP,MAAsB,wBAAtB;AACA,OAAOC,UAAP,MAAuB,mCAAvB;AACA,SAASC,oBAAT,EAA+BC,iBAA/B,QAAwD,mBAAxD;AACA,SAASC,GAAT,QAAoB,gBAApB;AACA,SAASC,0BAAT,EAAqCC,iCAArC,EAAwEC,kBAAxE,EAA4FC,cAA5F,QAAkH,kBAAlH;AACA,MAAMC,aAAa,GAAG,CAAC;AACrBC,EAAAA,QAAQ,EAAEP;AADW,CAAD,CAAtB;;AAIA,MAAMQ,WAAW,GAAG,MAAMC,OAAO,CAACC,OAAR,CAAgB,CAAC,EAAEC,MAAM,CAACC,SAAP,IAAoBD,MAAM,CAACC,SAAP,CAAiBC,GAAvC,CAAjB,CAA1B;;AAEA,MAAMC,MAAM,GAAG,MAAM;AACnB;AACA,QAAM;AACJD,IAAAA;AADI,MAEFD,SAFJ;AAGA,MAAI,CAACC,GAAL,EAAU,MAAM,IAAIR,cAAJ,CAAmB,gCAAnB,EAAqD,iBAArD,CAAN;AACV,SAAOQ,GAAP;AACD,CAPD;;SASeE,oB;;;;;4CAAf,aAAsC;AACpC,UAAMC,MAAM,SAASF,MAAM,GAAGG,aAAT,CAAuB;AAC1CC,MAAAA,OAAO,EAAEZ;AADiC,KAAvB,CAArB;AAGA,QAAIa,KAAK,CAACC,OAAN,CAAcJ,MAAd,CAAJ,EAA2B,OAAOA,MAAP;AAC3B,WAAO,CAACA,MAAD,CAAP;AACD,G;;;;SAEcK,gB;;;;;wCAAf,aAAkC;AAChC,UAAMC,OAAO,SAASR,MAAM,GAAGS,UAAT,EAAtB;AACA,WAAOD,OAAO,CAACE,MAAR,CAAeC,CAAC,IAAIA,CAAC,CAAClB,QAAF,KAAeP,iBAAnC,CAAP;AACD,G;;;;SAEc0B,oB;;;AAMf;AACA;AACA;AACA;AACA;AACA;AACA;;;;4CAZA,aAAsC;AACpC,UAAMC,eAAe,SAASN,gBAAgB,EAA9C;AACA,QAAIM,eAAe,CAACC,MAAhB,GAAyB,CAA7B,EAAgC,OAAOD,eAAe,CAAC,CAAD,CAAtB;AAChC,UAAML,OAAO,SAASP,oBAAoB,EAA1C;AACA,WAAOO,OAAO,CAAC,CAAD,CAAd;AACD,G;;;;AAUD,eAAe,MAAMO,eAAN,SAA8BhC,SAA9B,CAAwC;AACrDiC,EAAAA,WAAW,CAACd,MAAD,EAAS;AAAA;;AAClB,WADkB;AAAA;AAElB,SAAKA,MAAL,GAAc,KAAK,CAAnB;AACA,SAAKe,WAAL,GAAmB,KAAK,CAAxB;AACA,SAAKC,OAAL,GAAeC,IAAI,CAACC,KAAL,CAAWD,IAAI,CAACE,MAAL,KAAgB,MAA3B,CAAf;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACA,SAAKC,MAAL,GAAc,EAAd;AACA,SAAKC,aAAL,GAAqB,KAAK,CAA1B;;AAEA,SAAKC,IAAL,GAAY,MAAM;AAChB,UAAI,KAAKF,MAAL,CAAYT,MAAhB,EAAwB;AACtB,eAAOnB,OAAO,CAACC,OAAR,CAAgB,KAAK2B,MAAL,CAAYG,KAAZ,EAAhB,CAAP;AACD;;AAED,aAAO,IAAI/B,OAAJ,CAAYgC,OAAO,IAAI;AAC5B,aAAKH,aAAL,GAAqBG,OAArB;AACD,OAFM,CAAP;AAGD,KARD;;AAUA,SAAKC,aAAL,GAAqBC,CAAC,IAAI;AACxB,YAAMC,MAAM,GAAGC,MAAM,CAACC,IAAP,CAAYH,CAAC,CAACI,IAAF,CAAOH,MAAnB,CAAf;;AAEA,UAAI,KAAKN,aAAT,EAAwB;AACtB,aAAKA,aAAL,CAAmBM,MAAnB;AACA,aAAKN,aAAL,GAAqB,IAArB;AACD,OAHD,MAGO;AACL,aAAKD,MAAL,CAAYW,IAAZ,CAAiBJ,MAAjB;AACD;AACF,KATD;;AAWA,SAAKK,kBAAL,GAA0B,KAA1B;;AAEA,SAAKC,eAAL,GAAuBP,CAAC,IAAI;AAC1B,UAAI,KAAKM,kBAAT,EAA6B;AAC7B,WAAKA,kBAAL,GAA0B,IAA1B;AACA,WAAKE,IAAL,CAAU,YAAV,EAAwBR,CAAxB;AACD,KAJD;;AAMA,SAAKS,QAAL,GAAgBC,IAAI,IAAI,KAAKC,kBAAL,iCAAwB,aAAY;AAC1D,YAAM;AACJtB,QAAAA,OADI;AAEJI,QAAAA;AAFI,UAGF,KAHJ;AAIAnC,MAAAA,GAAG,CAAC,MAAD,EAAS,QAAQoD,IAAI,CAACE,QAAL,CAAc,KAAd,CAAjB,CAAH;AACA,YAAMC,OAAO,GAAG1D,UAAU,CAACkC,OAAD,EAAUI,UAAV,CAA1B,CAN0D,CAMT;;AAEjD,YAAMqB,MAAM,GAAGD,OAAO,CAACE,UAAR,CAAmBL,IAAnB,CAAf;;AAEA,WAAK,IAAIM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAAM,CAAC7B,MAA3B,EAAmC+B,CAAC,EAApC,EAAwC;AACtC,cAAM,KAAI,CAAC3C,MAAL,CAAY4C,UAAZ,CAAuB,CAAvB,EAA0BH,MAAM,CAACE,CAAD,CAAhC,CAAN;AACD,OAZyD,CAYxD;;;AAGF,UAAIE,MAAJ;AACA,UAAIC,GAAJ;;AAEA,aAAO,EAAED,MAAM,GAAGL,OAAO,CAACO,gBAAR,CAAyBD,GAAzB,CAAX,CAAP,EAAkD;AAChD,cAAMlB,MAAM,SAAS,KAAI,CAACL,IAAL,EAArB;AACAuB,QAAAA,GAAG,GAAGN,OAAO,CAACQ,cAAR,CAAuBF,GAAvB,EAA4BlB,MAA5B,CAAN;AACD;;AAED3C,MAAAA,GAAG,CAAC,MAAD,EAAS,QAAQ4D,MAAM,CAACN,QAAP,CAAgB,KAAhB,CAAjB,CAAH;AACA,aAAOM,MAAP;AACD,KAzBuB,GAyBrBI,KAzBqB,CAyBftB,CAAC,IAAI;AACZ,UAAIA,CAAC,IAAIA,CAAC,CAACuB,OAAP,IAAkBvB,CAAC,CAACuB,OAAF,CAAUC,QAAV,CAAmB,OAAnB,CAAtB,EAAmD;AACjD,aAAKjB,eAAL,CAAqBP,CAArB;;AAEA,cAAM,IAAIxC,iCAAJ,CAAsCwC,CAAC,CAACuB,OAAxC,CAAN;AACD;;AAED,YAAMvB,CAAN;AACD,KAjCuB,CAAxB;;AAmCA,SAAK3B,MAAL,GAAcA,MAAd;AACA,SAAKe,WAAL,GAAmBhC,oBAAoB,CAACiB,MAAM,CAACoD,SAAR,CAAvC;AACApD,IAAAA,MAAM,CAACqD,gBAAP,CAAwB,aAAxB,EAAuC,KAAK3B,aAA5C;AACD;AAED;AACF;AACA;;;AACsB,SAAP4B,OAAO,GAAG;AAAA;AACrB,YAAM,CAACtD,MAAD,UAAiBD,oBAAoB,EAA3C;AACA,aAAOc,eAAe,CAAC0C,IAAhB,CAAqBvD,MAArB,CAAP;AAFqB;AAGtB;AACD;AACF;AACA;;;AAG4B,SAAbwD,aAAa,GAAG;AAAA;AAC3B,YAAMlD,OAAO,SAASD,gBAAgB,EAAtC;AACA,UAAIC,OAAO,CAACM,MAAR,KAAmB,CAAvB,EAA0B,OAAO,IAAP;AAC1B,aAAOC,eAAe,CAAC0C,IAAhB,CAAqBjD,OAAO,CAAC,CAAD,CAA5B,CAAP;AAH2B;AAI5B;AACD;AACF;AACA;;;AAGmB,SAAJiD,IAAI,CAACvD,MAAD,EAAS;AAAA;AACxB,YAAMA,MAAM,CAACuD,IAAP,EAAN;AACA,YAAME,SAAS,GAAG,IAAI5C,eAAJ,CAAoBb,MAApB,CAAlB;;AAEA,YAAM0D,YAAY,GAAG/B,CAAC,IAAI;AACxB,YAAI3B,MAAM,KAAK2B,CAAC,CAAC3B,MAAjB,EAAyB;AACvBF,UAAAA,MAAM,GAAG6D,mBAAT,CAA6B,YAA7B,EAA2CD,YAA3C;;AAEAD,UAAAA,SAAS,CAACvB,eAAV,CAA0B,IAAI9C,kBAAJ,EAA1B;AACD;AACF,OAND;;AAQAU,MAAAA,MAAM,GAAGuD,gBAAT,CAA0B,YAA1B,EAAwCK,YAAxC;AACA,aAAOD,SAAP;AAbwB;AAczB;AAED;AACF;AACA;;;AACQG,EAAAA,KAAK,GAAG;AAAA;;AAAA;AACZ,YAAM,MAAI,CAACC,mBAAX;;AACA,MAAA,MAAI,CAAC7D,MAAL,CAAY2D,mBAAZ,CAAgC,aAAhC,EAA+C,MAAI,CAACjC,aAApD;;AACA,YAAM,MAAI,CAAC1B,MAAL,CAAY4D,KAAZ,EAAN;AAHY;AAIb;AACD;AACF;AACA;AACA;AACA;;;AAGEE,EAAAA,cAAc,GAAG,CAAE;;AApIkC;AAuIvDjD,eAAe,CAACrB,WAAhB,GAA8BA,WAA9B;AACAqB,eAAe,CAACkD,IAAhB,GAAuB1D,gBAAvB;;AAEAQ,eAAe,CAACmD,MAAhB,GAAyBC,QAAQ,IAAI;AACnC,MAAIC,YAAY,GAAG,KAAnB;AACAxD,EAAAA,oBAAoB,GAAGyD,IAAvB,CAA4BnE,MAAM,IAAI;AACpC,QAAI,CAACA,MAAL,EAAa;AACXiE,MAAAA,QAAQ,CAACG,KAAT,CAAe,IAAIlF,0BAAJ,CAA+B,oCAA/B,CAAf;AACD,KAFD,MAEO,IAAI,CAACgF,YAAL,EAAmB;AACxB,YAAMnD,WAAW,GAAGhC,oBAAoB,CAACiB,MAAM,CAACoD,SAAR,CAAxC;AACAa,MAAAA,QAAQ,CAACI,IAAT,CAAc;AACZC,QAAAA,IAAI,EAAE,KADM;AAEZC,QAAAA,UAAU,EAAEvE,MAFA;AAGZe,QAAAA;AAHY,OAAd;AAKAkD,MAAAA,QAAQ,CAACO,QAAT;AACD;AACF,GAZD,EAYGJ,KAAK,IAAI;AACVH,IAAAA,QAAQ,CAACG,KAAT,CAAe,IAAIlF,0BAAJ,CAA+BkF,KAAK,CAAClB,OAArC,CAAf;AACD,GAdD;;AAgBA,WAASuB,WAAT,GAAuB;AACrBP,IAAAA,YAAY,GAAG,IAAf;AACD;;AAED,SAAO;AACLO,IAAAA;AADK,GAAP;AAGD,CAzBD","sourcesContent":["import Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, DisconnectedDeviceDuringOperation, DisconnectedDevice, TransportError } from \"@ledgerhq/errors\";\nconst ledgerDevices = [{\n  vendorId: ledgerUSBVendorId\n}];\n\nconst isSupported = () => Promise.resolve(!!(global.navigator && global.navigator.hid));\n\nconst getHID = () => {\n  // $FlowFixMe\n  const {\n    hid\n  } = navigator;\n  if (!hid) throw new TransportError(\"navigator.hid is not supported\", \"HIDNotSupported\");\n  return hid;\n};\n\nasync function requestLedgerDevices() {\n  const device = await getHID().requestDevice({\n    filters: ledgerDevices\n  });\n  if (Array.isArray(device)) return device;\n  return [device];\n}\n\nasync function getLedgerDevices() {\n  const devices = await getHID().getDevices();\n  return devices.filter(d => d.vendorId === ledgerUSBVendorId);\n}\n\nasync function getFirstLedgerDevice() {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  const devices = await requestLedgerDevices();\n  return devices[0];\n}\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\n\n\nexport default class TransportWebHID extends Transport {\n  constructor(device) {\n    super();\n    this.device = void 0;\n    this.deviceModel = void 0;\n    this.channel = Math.floor(Math.random() * 0xffff);\n    this.packetSize = 64;\n    this.inputs = [];\n    this.inputCallback = void 0;\n\n    this.read = () => {\n      if (this.inputs.length) {\n        return Promise.resolve(this.inputs.shift());\n      }\n\n      return new Promise(success => {\n        this.inputCallback = success;\n      });\n    };\n\n    this.onInputReport = e => {\n      const buffer = Buffer.from(e.data.buffer);\n\n      if (this.inputCallback) {\n        this.inputCallback(buffer);\n        this.inputCallback = null;\n      } else {\n        this.inputs.push(buffer);\n      }\n    };\n\n    this._disconnectEmitted = false;\n\n    this._emitDisconnect = e => {\n      if (this._disconnectEmitted) return;\n      this._disconnectEmitted = true;\n      this.emit(\"disconnect\", e);\n    };\n\n    this.exchange = apdu => this.exchangeAtomicImpl(async () => {\n      const {\n        channel,\n        packetSize\n      } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n      const framing = hidFraming(channel, packetSize); // Write...\n\n      const blocks = framing.makeBlocks(apdu);\n\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.sendReport(0, blocks[i]);\n      } // Read...\n\n\n      let result;\n      let acc;\n\n      while (!(result = framing.getReducedResult(acc))) {\n        const buffer = await this.read();\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch(e => {\n      if (e && e.message && e.message.includes(\"write\")) {\n        this._emitDisconnect(e);\n\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n\n      throw e;\n    });\n\n    this.device = device;\n    this.deviceModel = identifyUSBProductId(device.productId);\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const [device] = await requestLedgerDevices();\n    return TransportWebHID.open(device);\n  }\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n\n\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebHID.open(devices[0]);\n  }\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n\n\n  static async open(device) {\n    await device.open();\n    const transport = new TransportWebHID(device);\n\n    const onDisconnect = e => {\n      if (device === e.device) {\n        getHID().removeEventListener(\"disconnect\", onDisconnect);\n\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n\n    getHID().addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  /**\n   * Release the transport device\n   */\n  async close() {\n    await this.exchangeBusyPromise;\n    this.device.removeEventListener(\"inputreport\", this.onInputReport);\n    await this.device.close();\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n\n  setScrambleKey() {}\n\n}\nTransportWebHID.isSupported = isSupported;\nTransportWebHID.list = getLedgerDevices;\n\nTransportWebHID.listen = observer => {\n  let unsubscribed = false;\n  getFirstLedgerDevice().then(device => {\n    if (!device) {\n      observer.error(new TransportOpenUserCancelled(\"Access denied to use Ledger device\"));\n    } else if (!unsubscribed) {\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device,\n        deviceModel\n      });\n      observer.complete();\n    }\n  }, error => {\n    observer.error(new TransportOpenUserCancelled(error.message));\n  });\n\n  function unsubscribe() {\n    unsubscribed = true;\n  }\n\n  return {\n    unsubscribe\n  };\n};\n"]},"metadata":{},"sourceType":"module"}