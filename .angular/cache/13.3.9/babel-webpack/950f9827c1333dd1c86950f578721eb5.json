{"ast":null,"code":"import _asyncToGenerator from \"/Users/robimarkac/Development/openmoneymarket-frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport EventEmitter from \"events\";\nimport { TransportRaceCondition, TransportError, StatusCodes, getAltStatusMessage, TransportStatusError } from \"@ledgerhq/errors\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\n/**\n */\n\n/**\n * Transport defines the generic interface to share between node/u2f impl\n * A **Descriptor** is a parametric type that is up to be determined for the implementation.\n * it can be for instance an ID, an file path, a URL,...\n */\n\nexport default class Transport {\n  constructor() {\n    var _this = this;\n\n    this.exchangeTimeout = 30000;\n    this.unresponsiveTimeout = 15000;\n    this.deviceModel = null;\n    this._events = new EventEmitter();\n\n    this.send = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (cla, ins, p1, p2, data = Buffer.alloc(0), statusList = [StatusCodes.OK]) {\n        if (data.length >= 256) {\n          throw new TransportError(\"data.length exceed 256 bytes limit. Got: \" + data.length, \"DataLengthTooBig\");\n        }\n\n        const response = yield _this.exchange(Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]));\n        const sw = response.readUInt16BE(response.length - 2);\n\n        if (!statusList.some(s => s === sw)) {\n          throw new TransportStatusError(sw);\n        }\n\n        return response;\n      });\n\n      return function (_x, _x2, _x3, _x4) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n\n    this.exchangeBusyPromise = void 0;\n\n    this.exchangeAtomicImpl = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (f) {\n        if (_this.exchangeBusyPromise) {\n          throw new TransportRaceCondition(\"An action was already pending on the Ledger device. Please deny or reconnect.\");\n        }\n\n        let resolveBusy;\n        const busyPromise = new Promise(r => {\n          resolveBusy = r;\n        });\n        _this.exchangeBusyPromise = busyPromise;\n        let unresponsiveReached = false;\n        const timeout = setTimeout(() => {\n          unresponsiveReached = true;\n\n          _this.emit(\"unresponsive\");\n        }, _this.unresponsiveTimeout);\n\n        try {\n          const res = yield f();\n\n          if (unresponsiveReached) {\n            _this.emit(\"responsive\");\n          }\n\n          return res;\n        } finally {\n          clearTimeout(timeout);\n          if (resolveBusy) resolveBusy();\n          _this.exchangeBusyPromise = null;\n        }\n      });\n\n      return function (_x5) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n\n    this._appAPIlock = null;\n  }\n  /**\n   * low level api to communicate with the device\n   * This method is for implementations to implement but should not be directly called.\n   * Instead, the recommanded way is to use send() method\n   * @param apdu the data to send\n   * @return a Promise of response data\n   */\n\n\n  exchange(_apdu) {\n    throw new Error(\"exchange not implemented\");\n  }\n  /**\n   * set the \"scramble key\" for the next exchanges with the device.\n   * Each App can have a different scramble key and they internally will set it at instanciation.\n   * @param key the scramble key\n   */\n\n\n  setScrambleKey(_key) {}\n  /**\n   * close the exchange with the device.\n   * @return a Promise that ends when the transport is closed.\n   */\n\n\n  close() {\n    return Promise.resolve();\n  }\n  /**\n   * Listen to an event on an instance of transport.\n   * Transport implementation can have specific events. Here is the common events:\n   * * `\"disconnect\"` : triggered if Transport is disconnected\n   */\n\n\n  on(eventName, cb) {\n    this._events.on(eventName, cb);\n  }\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n\n\n  off(eventName, cb) {\n    this._events.removeListener(eventName, cb);\n  }\n\n  emit(event, ...args) {\n    this._events.emit(event, ...args);\n  }\n  /**\n   * Enable or not logs of the binary exchange\n   */\n\n\n  setDebugMode() {\n    console.warn(\"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\");\n  }\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n\n\n  setExchangeTimeout(exchangeTimeout) {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n\n\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout) {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n  /**\n   * wrapper on top of exchange to simplify work of the implementation.\n   * @param cla\n   * @param ins\n   * @param p1\n   * @param p2\n   * @param data\n   * @param statusList is a list of accepted status code (shorts). [0x9000] by default\n   * @return a Promise of response buffer\n   */\n\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\n  TransportFoo.create().then(transport => ...)\n   */\n\n\n  static create(openTimeout = 3000, listenTimeout) {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: e => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: e => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n\n          if (!found) {\n            reject(new TransportError(this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n          }\n        }\n      });\n      const listenTimeoutId = listenTimeout ? setTimeout(() => {\n        sub.unsubscribe();\n        reject(new TransportError(this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n      }, listenTimeout) : null;\n    });\n  }\n\n  decorateAppAPIMethods(self, methods, scrambleKey) {\n    for (let methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n    }\n  }\n\n  decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {\n    var _this2 = this;\n\n    return /*#__PURE__*/_asyncToGenerator(function* (...args) {\n      const {\n        _appAPIlock\n      } = _this2;\n\n      if (_appAPIlock) {\n        return Promise.reject(new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"));\n      }\n\n      try {\n        _this2._appAPIlock = methodName;\n\n        _this2.setScrambleKey(scrambleKey);\n\n        return yield f.apply(ctx, args);\n      } finally {\n        _this2._appAPIlock = null;\n      }\n    });\n  }\n\n}\nTransport.isSupported = void 0;\nTransport.list = void 0;\nTransport.listen = void 0;\nTransport.open = void 0;\nTransport.ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\nTransport.ErrorMessage_NoDeviceFound = \"No Ledger device found\";","map":{"version":3,"sources":["/Users/robimarkac/Development/openmoneymarket-frontend/node_modules/@ledgerhq/hw-transport/lib-es/Transport.js"],"names":["EventEmitter","TransportRaceCondition","TransportError","StatusCodes","getAltStatusMessage","TransportStatusError","Transport","constructor","exchangeTimeout","unresponsiveTimeout","deviceModel","_events","send","cla","ins","p1","p2","data","Buffer","alloc","statusList","OK","length","response","exchange","concat","from","sw","readUInt16BE","some","s","exchangeBusyPromise","exchangeAtomicImpl","f","resolveBusy","busyPromise","Promise","r","unresponsiveReached","timeout","setTimeout","emit","res","clearTimeout","_appAPIlock","_apdu","Error","setScrambleKey","_key","close","resolve","on","eventName","cb","off","removeListener","event","args","setDebugMode","console","warn","setExchangeTimeout","setExchangeUnresponsiveTimeout","create","openTimeout","listenTimeout","reject","found","sub","listen","next","e","unsubscribe","listenTimeoutId","open","descriptor","then","error","complete","ErrorMessage_NoDeviceFound","ErrorMessage_ListenTimeout","decorateAppAPIMethods","self","methods","scrambleKey","methodName","decorateAppAPIMethod","ctx","apply","isSupported","list"],"mappings":";AAAA,OAAOA,YAAP,MAAyB,QAAzB;AACA,SAASC,sBAAT,EAAiCC,cAAjC,EAAiDC,WAAjD,EAA8DC,mBAA9D,EAAmFC,oBAAnF,QAA+G,kBAA/G;AACA,SAASH,cAAT,EAAyBG,oBAAzB,EAA+CF,WAA/C,EAA4DC,mBAA5D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AACA,eAAe,MAAME,SAAN,CAAgB;AAC7BC,EAAAA,WAAW,GAAG;AAAA;;AACZ,SAAKC,eAAL,GAAuB,KAAvB;AACA,SAAKC,mBAAL,GAA2B,KAA3B;AACA,SAAKC,WAAL,GAAmB,IAAnB;AACA,SAAKC,OAAL,GAAe,IAAIX,YAAJ,EAAf;;AAEA,SAAKY,IAAL;AAAA,mCAAY,WAAOC,GAAP,EAAYC,GAAZ,EAAiBC,EAAjB,EAAqBC,EAArB,EAAyBC,IAAI,GAAGC,MAAM,CAACC,KAAP,CAAa,CAAb,CAAhC,EAAiDC,UAAU,GAAG,CAACjB,WAAW,CAACkB,EAAb,CAA9D,EAAmF;AAC7F,YAAIJ,IAAI,CAACK,MAAL,IAAe,GAAnB,EAAwB;AACtB,gBAAM,IAAIpB,cAAJ,CAAmB,8CAA8Ce,IAAI,CAACK,MAAtE,EAA8E,kBAA9E,CAAN;AACD;;AAED,cAAMC,QAAQ,SAAS,KAAI,CAACC,QAAL,CAAcN,MAAM,CAACO,MAAP,CAAc,CAACP,MAAM,CAACQ,IAAP,CAAY,CAACb,GAAD,EAAMC,GAAN,EAAWC,EAAX,EAAeC,EAAf,CAAZ,CAAD,EAAkCE,MAAM,CAACQ,IAAP,CAAY,CAACT,IAAI,CAACK,MAAN,CAAZ,CAAlC,EAA8DL,IAA9D,CAAd,CAAd,CAAvB;AACA,cAAMU,EAAE,GAAGJ,QAAQ,CAACK,YAAT,CAAsBL,QAAQ,CAACD,MAAT,GAAkB,CAAxC,CAAX;;AAEA,YAAI,CAACF,UAAU,CAACS,IAAX,CAAgBC,CAAC,IAAIA,CAAC,KAAKH,EAA3B,CAAL,EAAqC;AACnC,gBAAM,IAAItB,oBAAJ,CAAyBsB,EAAzB,CAAN;AACD;;AAED,eAAOJ,QAAP;AACD,OAbD;;AAAA;AAAA;AAAA;AAAA;;AAeA,SAAKQ,mBAAL,GAA2B,KAAK,CAAhC;;AAEA,SAAKC,kBAAL;AAAA,oCAA0B,WAAMC,CAAN,EAAW;AACnC,YAAI,KAAI,CAACF,mBAAT,EAA8B;AAC5B,gBAAM,IAAI9B,sBAAJ,CAA2B,+EAA3B,CAAN;AACD;;AAED,YAAIiC,WAAJ;AACA,cAAMC,WAAW,GAAG,IAAIC,OAAJ,CAAYC,CAAC,IAAI;AACnCH,UAAAA,WAAW,GAAGG,CAAd;AACD,SAFmB,CAApB;AAGA,QAAA,KAAI,CAACN,mBAAL,GAA2BI,WAA3B;AACA,YAAIG,mBAAmB,GAAG,KAA1B;AACA,cAAMC,OAAO,GAAGC,UAAU,CAAC,MAAM;AAC/BF,UAAAA,mBAAmB,GAAG,IAAtB;;AACA,UAAA,KAAI,CAACG,IAAL,CAAU,cAAV;AACD,SAHyB,EAGvB,KAAI,CAAChC,mBAHkB,CAA1B;;AAKA,YAAI;AACF,gBAAMiC,GAAG,SAAST,CAAC,EAAnB;;AAEA,cAAIK,mBAAJ,EAAyB;AACvB,YAAA,KAAI,CAACG,IAAL,CAAU,YAAV;AACD;;AAED,iBAAOC,GAAP;AACD,SARD,SAQU;AACRC,UAAAA,YAAY,CAACJ,OAAD,CAAZ;AACA,cAAIL,WAAJ,EAAiBA,WAAW;AAC5B,UAAA,KAAI,CAACH,mBAAL,GAA2B,IAA3B;AACD;AACF,OA7BD;;AAAA;AAAA;AAAA;AAAA;;AA+BA,SAAKa,WAAL,GAAmB,IAAnB;AACD;AAED;AACF;AACA;AACA;AACA;AACA;AACA;;;AACEpB,EAAAA,QAAQ,CAACqB,KAAD,EAAQ;AACd,UAAM,IAAIC,KAAJ,CAAU,0BAAV,CAAN;AACD;AACD;AACF;AACA;AACA;AACA;;;AAGEC,EAAAA,cAAc,CAACC,IAAD,EAAO,CAAE;AACvB;AACF;AACA;AACA;;;AAGEC,EAAAA,KAAK,GAAG;AACN,WAAOb,OAAO,CAACc,OAAR,EAAP;AACD;AAED;AACF;AACA;AACA;AACA;;;AACEC,EAAAA,EAAE,CAACC,SAAD,EAAYC,EAAZ,EAAgB;AAChB,SAAK1C,OAAL,CAAawC,EAAb,CAAgBC,SAAhB,EAA2BC,EAA3B;AACD;AACD;AACF;AACA;;;AAGEC,EAAAA,GAAG,CAACF,SAAD,EAAYC,EAAZ,EAAgB;AACjB,SAAK1C,OAAL,CAAa4C,cAAb,CAA4BH,SAA5B,EAAuCC,EAAvC;AACD;;AAEDZ,EAAAA,IAAI,CAACe,KAAD,EAAQ,GAAGC,IAAX,EAAiB;AACnB,SAAK9C,OAAL,CAAa8B,IAAb,CAAkBe,KAAlB,EAAyB,GAAGC,IAA5B;AACD;AACD;AACF;AACA;;;AAGEC,EAAAA,YAAY,GAAG;AACbC,IAAAA,OAAO,CAACC,IAAR,CAAa,8FAAb;AACD;AACD;AACF;AACA;;;AAGEC,EAAAA,kBAAkB,CAACrD,eAAD,EAAkB;AAClC,SAAKA,eAAL,GAAuBA,eAAvB;AACD;AACD;AACF;AACA;;;AAGEsD,EAAAA,8BAA8B,CAACrD,mBAAD,EAAsB;AAClD,SAAKA,mBAAL,GAA2BA,mBAA3B;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGE;AACF;AACA;AACA;AACA;AACA;AACA;;;AACe,SAANsD,MAAM,CAACC,WAAW,GAAG,IAAf,EAAqBC,aAArB,EAAoC;AAC/C,WAAO,IAAI7B,OAAJ,CAAY,CAACc,OAAD,EAAUgB,MAAV,KAAqB;AACtC,UAAIC,KAAK,GAAG,KAAZ;AACA,YAAMC,GAAG,GAAG,KAAKC,MAAL,CAAY;AACtBC,QAAAA,IAAI,EAAEC,CAAC,IAAI;AACTJ,UAAAA,KAAK,GAAG,IAAR;AACA,cAAIC,GAAJ,EAASA,GAAG,CAACI,WAAJ;AACT,cAAIC,eAAJ,EAAqB9B,YAAY,CAAC8B,eAAD,CAAZ;AACrB,eAAKC,IAAL,CAAUH,CAAC,CAACI,UAAZ,EAAwBX,WAAxB,EAAqCY,IAArC,CAA0C1B,OAA1C,EAAmDgB,MAAnD;AACD,SANqB;AAOtBW,QAAAA,KAAK,EAAEN,CAAC,IAAI;AACV,cAAIE,eAAJ,EAAqB9B,YAAY,CAAC8B,eAAD,CAAZ;AACrBP,UAAAA,MAAM,CAACK,CAAD,CAAN;AACD,SAVqB;AAWtBO,QAAAA,QAAQ,EAAE,MAAM;AACd,cAAIL,eAAJ,EAAqB9B,YAAY,CAAC8B,eAAD,CAAZ;;AAErB,cAAI,CAACN,KAAL,EAAY;AACVD,YAAAA,MAAM,CAAC,IAAIhE,cAAJ,CAAmB,KAAK6E,0BAAxB,EAAoD,eAApD,CAAD,CAAN;AACD;AACF;AAjBqB,OAAZ,CAAZ;AAmBA,YAAMN,eAAe,GAAGR,aAAa,GAAGzB,UAAU,CAAC,MAAM;AACvD4B,QAAAA,GAAG,CAACI,WAAJ;AACAN,QAAAA,MAAM,CAAC,IAAIhE,cAAJ,CAAmB,KAAK8E,0BAAxB,EAAoD,eAApD,CAAD,CAAN;AACD,OAHiD,EAG/Cf,aAH+C,CAAb,GAGjB,IAHpB;AAID,KAzBM,CAAP;AA0BD;;AAEDgB,EAAAA,qBAAqB,CAACC,IAAD,EAAOC,OAAP,EAAgBC,WAAhB,EAA6B;AAChD,SAAK,IAAIC,UAAT,IAAuBF,OAAvB,EAAgC;AAC9BD,MAAAA,IAAI,CAACG,UAAD,CAAJ,GAAmB,KAAKC,oBAAL,CAA0BD,UAA1B,EAAsCH,IAAI,CAACG,UAAD,CAA1C,EAAwDH,IAAxD,EAA8DE,WAA9D,CAAnB;AACD;AACF;;AAEDE,EAAAA,oBAAoB,CAACD,UAAD,EAAapD,CAAb,EAAgBsD,GAAhB,EAAqBH,WAArB,EAAkC;AAAA;;AACpD,0CAAO,WAAO,GAAG3B,IAAV,EAAmB;AACxB,YAAM;AACJb,QAAAA;AADI,UAEF,MAFJ;;AAIA,UAAIA,WAAJ,EAAiB;AACf,eAAOR,OAAO,CAAC8B,MAAR,CAAe,IAAIhE,cAAJ,CAAmB,iCAAiC0C,WAAjC,GAA+C,GAAlE,EAAuE,iBAAvE,CAAf,CAAP;AACD;;AAED,UAAI;AACF,QAAA,MAAI,CAACA,WAAL,GAAmByC,UAAnB;;AACA,QAAA,MAAI,CAACtC,cAAL,CAAoBqC,WAApB;;AACA,qBAAanD,CAAC,CAACuD,KAAF,CAAQD,GAAR,EAAa9B,IAAb,CAAb;AACD,OAJD,SAIU;AACR,QAAA,MAAI,CAACb,WAAL,GAAmB,IAAnB;AACD;AACF,KAhBD;AAiBD;;AA1M4B;AA6M/BtC,SAAS,CAACmF,WAAV,GAAwB,KAAK,CAA7B;AACAnF,SAAS,CAACoF,IAAV,GAAiB,KAAK,CAAtB;AACApF,SAAS,CAAC+D,MAAV,GAAmB,KAAK,CAAxB;AACA/D,SAAS,CAACoE,IAAV,GAAiB,KAAK,CAAtB;AACApE,SAAS,CAAC0E,0BAAV,GAAuC,kCAAvC;AACA1E,SAAS,CAACyE,0BAAV,GAAuC,wBAAvC","sourcesContent":["import EventEmitter from \"events\";\nimport { TransportRaceCondition, TransportError, StatusCodes, getAltStatusMessage, TransportStatusError } from \"@ledgerhq/errors\";\nexport { TransportError, TransportStatusError, StatusCodes, getAltStatusMessage };\n/**\n */\n\n/**\n * Transport defines the generic interface to share between node/u2f impl\n * A **Descriptor** is a parametric type that is up to be determined for the implementation.\n * it can be for instance an ID, an file path, a URL,...\n */\nexport default class Transport {\n  constructor() {\n    this.exchangeTimeout = 30000;\n    this.unresponsiveTimeout = 15000;\n    this.deviceModel = null;\n    this._events = new EventEmitter();\n\n    this.send = async (cla, ins, p1, p2, data = Buffer.alloc(0), statusList = [StatusCodes.OK]) => {\n      if (data.length >= 256) {\n        throw new TransportError(\"data.length exceed 256 bytes limit. Got: \" + data.length, \"DataLengthTooBig\");\n      }\n\n      const response = await this.exchange(Buffer.concat([Buffer.from([cla, ins, p1, p2]), Buffer.from([data.length]), data]));\n      const sw = response.readUInt16BE(response.length - 2);\n\n      if (!statusList.some(s => s === sw)) {\n        throw new TransportStatusError(sw);\n      }\n\n      return response;\n    };\n\n    this.exchangeBusyPromise = void 0;\n\n    this.exchangeAtomicImpl = async f => {\n      if (this.exchangeBusyPromise) {\n        throw new TransportRaceCondition(\"An action was already pending on the Ledger device. Please deny or reconnect.\");\n      }\n\n      let resolveBusy;\n      const busyPromise = new Promise(r => {\n        resolveBusy = r;\n      });\n      this.exchangeBusyPromise = busyPromise;\n      let unresponsiveReached = false;\n      const timeout = setTimeout(() => {\n        unresponsiveReached = true;\n        this.emit(\"unresponsive\");\n      }, this.unresponsiveTimeout);\n\n      try {\n        const res = await f();\n\n        if (unresponsiveReached) {\n          this.emit(\"responsive\");\n        }\n\n        return res;\n      } finally {\n        clearTimeout(timeout);\n        if (resolveBusy) resolveBusy();\n        this.exchangeBusyPromise = null;\n      }\n    };\n\n    this._appAPIlock = null;\n  }\n\n  /**\n   * low level api to communicate with the device\n   * This method is for implementations to implement but should not be directly called.\n   * Instead, the recommanded way is to use send() method\n   * @param apdu the data to send\n   * @return a Promise of response data\n   */\n  exchange(_apdu) {\n    throw new Error(\"exchange not implemented\");\n  }\n  /**\n   * set the \"scramble key\" for the next exchanges with the device.\n   * Each App can have a different scramble key and they internally will set it at instanciation.\n   * @param key the scramble key\n   */\n\n\n  setScrambleKey(_key) {}\n  /**\n   * close the exchange with the device.\n   * @return a Promise that ends when the transport is closed.\n   */\n\n\n  close() {\n    return Promise.resolve();\n  }\n\n  /**\n   * Listen to an event on an instance of transport.\n   * Transport implementation can have specific events. Here is the common events:\n   * * `\"disconnect\"` : triggered if Transport is disconnected\n   */\n  on(eventName, cb) {\n    this._events.on(eventName, cb);\n  }\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n\n\n  off(eventName, cb) {\n    this._events.removeListener(eventName, cb);\n  }\n\n  emit(event, ...args) {\n    this._events.emit(event, ...args);\n  }\n  /**\n   * Enable or not logs of the binary exchange\n   */\n\n\n  setDebugMode() {\n    console.warn(\"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\");\n  }\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n\n\n  setExchangeTimeout(exchangeTimeout) {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n  /**\n   * Define the delay before emitting \"unresponsive\" on an exchange that does not respond\n   */\n\n\n  setExchangeUnresponsiveTimeout(unresponsiveTimeout) {\n    this.unresponsiveTimeout = unresponsiveTimeout;\n  }\n  /**\n   * wrapper on top of exchange to simplify work of the implementation.\n   * @param cla\n   * @param ins\n   * @param p1\n   * @param p2\n   * @param data\n   * @param statusList is a list of accepted status code (shorts). [0x9000] by default\n   * @return a Promise of response buffer\n   */\n\n\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\n  TransportFoo.create().then(transport => ...)\n   */\n  static create(openTimeout = 3000, listenTimeout) {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: e => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: e => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n\n          if (!found) {\n            reject(new TransportError(this.ErrorMessage_NoDeviceFound, \"NoDeviceFound\"));\n          }\n        }\n      });\n      const listenTimeoutId = listenTimeout ? setTimeout(() => {\n        sub.unsubscribe();\n        reject(new TransportError(this.ErrorMessage_ListenTimeout, \"ListenTimeout\"));\n      }, listenTimeout) : null;\n    });\n  }\n\n  decorateAppAPIMethods(self, methods, scrambleKey) {\n    for (let methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(methodName, self[methodName], self, scrambleKey);\n    }\n  }\n\n  decorateAppAPIMethod(methodName, f, ctx, scrambleKey) {\n    return async (...args) => {\n      const {\n        _appAPIlock\n      } = this;\n\n      if (_appAPIlock) {\n        return Promise.reject(new TransportError(\"Ledger Device is busy (lock \" + _appAPIlock + \")\", \"TransportLocked\"));\n      }\n\n      try {\n        this._appAPIlock = methodName;\n        this.setScrambleKey(scrambleKey);\n        return await f.apply(ctx, args);\n      } finally {\n        this._appAPIlock = null;\n      }\n    };\n  }\n\n}\nTransport.isSupported = void 0;\nTransport.list = void 0;\nTransport.listen = void 0;\nTransport.open = void 0;\nTransport.ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\nTransport.ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n"]},"metadata":{},"sourceType":"module"}