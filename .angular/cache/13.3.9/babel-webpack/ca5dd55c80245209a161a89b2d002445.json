{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, Inject, EventEmitter, Component, ChangeDetectionStrategy, Input, Output, NgModule } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport * as i4 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n/**\n * Notification\n *\n * This class describes the structure of a notifiction, including all information it needs to live, and everyone else needs to work with it.\n */\n\nconst _c0 = function (a0) {\n  return {\n    notification: a0\n  };\n};\n\nfunction NotifierNotificationComponent_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0, 2);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.notification.template)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c0, ctx_r0.notification));\n  }\n}\n\nfunction NotifierNotificationComponent_ng_template_1_button_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"button\", 5);\n    i0.ɵɵlistener(\"click\", function NotifierNotificationComponent_ng_template_1_button_2_Template_button_click_0_listener() {\n      i0.ɵɵrestoreView(_r5);\n      const ctx_r4 = i0.ɵɵnextContext(2);\n      return ctx_r4.onClickDismiss();\n    });\n    i0.ɵɵnamespaceSVG();\n    i0.ɵɵelementStart(1, \"svg\", 6);\n    i0.ɵɵelement(2, \"path\", 7);\n    i0.ɵɵelementEnd()();\n  }\n}\n\nfunction NotifierNotificationComponent_ng_template_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"p\", 3);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(2, NotifierNotificationComponent_ng_template_1_button_2_Template, 3, 0, \"button\", 4);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r2.notification.message);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r2.config.behaviour.showDismissButton);\n  }\n}\n\nfunction NotifierContainerComponent_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r3 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"li\", 2)(1, \"notifier-notification\", 3);\n    i0.ɵɵlistener(\"ready\", function NotifierContainerComponent_li_1_Template_notifier_notification_ready_1_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r2 = i0.ɵɵnextContext();\n      return ctx_r2.onNotificationReady($event);\n    })(\"dismiss\", function NotifierContainerComponent_li_1_Template_notifier_notification_dismiss_1_listener($event) {\n      i0.ɵɵrestoreView(_r3);\n      const ctx_r4 = i0.ɵɵnextContext();\n      return ctx_r4.onNotificationDismiss($event);\n    });\n    i0.ɵɵelementEnd()();\n  }\n\n  if (rf & 2) {\n    const notification_r1 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"notification\", notification_r1);\n  }\n}\n\nclass NotifierNotification {\n  /**\n   * Constructor\n   *\n   * @param options Notifier options\n   */\n  constructor(options) {\n    /**\n     * The template to customize\n     * the appearance of the notification\n     */\n    this.template = null;\n    Object.assign(this, options); // If not set manually, we have to create a unique notification ID by ourselves. The ID generation relies on the current browser\n    // datetime in ms, in praticular the moment this notification gets constructed. Concurrency, and thus two IDs being the exact same,\n    // is not possible due to the action queue concept.\n\n    if (options.id === undefined) {\n      this.id = `ID_${new Date().getTime()}`;\n    }\n  }\n\n}\n/**\n * Notifier queue service\n *\n * In general, API calls don't get processed right away. Instead, we have to queue them up in order to prevent simultanious API calls\n * interfering with each other. This, at least in theory, is possible at any time. In particular, animations - which potentially overlap -\n * can cause changes in JS classes as well as affect the DOM. Therefore, the queue service takes all actions, puts them in a queue, and\n * processes them at the right time (which is when the previous action has been processed successfully).\n *\n * Technical sidenote:\n * An action looks pretty similar to the ones within the Flux / Redux pattern.\n */\n\n\nclass NotifierQueueService {\n  /**\n   * Constructor\n   */\n  constructor() {\n    this.actionStream = new Subject();\n    this.actionQueue = [];\n    this.isActionInProgress = false;\n  }\n  /**\n   * Push a new action to the queue, and try to run it\n   *\n   * @param action Action object\n   */\n\n\n  push(action) {\n    this.actionQueue.push(action);\n    this.tryToRunNextAction();\n  }\n  /**\n   * Continue with the next action (called when the current action is finished)\n   */\n\n\n  continue() {\n    this.isActionInProgress = false;\n    this.tryToRunNextAction();\n  }\n  /**\n   * Try to run the next action in the queue; we skip if there already is some action in progress, or if there is no action left\n   */\n\n\n  tryToRunNextAction() {\n    if (this.isActionInProgress || this.actionQueue.length === 0) {\n      return; // Skip (the queue can now go drink a coffee as it has nothing to do anymore)\n    }\n\n    this.isActionInProgress = true;\n    this.actionStream.next(this.actionQueue.shift()); // Push next action to the stream, and remove the current action from the queue\n  }\n\n}\n\nNotifierQueueService.ɵfac = function NotifierQueueService_Factory(t) {\n  return new (t || NotifierQueueService)();\n};\n\nNotifierQueueService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NotifierQueueService,\n  factory: NotifierQueueService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NotifierQueueService, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\n * Injection Token for notifier options\n */\n\n\nconst NotifierOptionsToken = new InjectionToken('[angular-notifier] Notifier Options');\n/**\n * Injection Token for notifier configuration\n */\n\nconst NotifierConfigToken = new InjectionToken('[anuglar-notifier] Notifier Config');\n/**\n * Notifier configuration\n *\n * The notifier configuration defines what notifications look like, how they behave, and how they get animated. It is a global\n * configuration, which means that it only can be set once (at the beginning), and cannot be changed afterwards. Aligning to the world of\n * Angular, this configuration can be provided in the root app module - alternatively, a meaningful default configuration will be used.\n */\n\nclass NotifierConfig {\n  /**\n   * Constructor\n   *\n   * @param [customOptions={}] Custom notifier options, optional\n   */\n  constructor(customOptions = {}) {\n    // Set default values\n    this.animations = {\n      enabled: true,\n      hide: {\n        easing: 'ease',\n        offset: 50,\n        preset: 'fade',\n        speed: 300\n      },\n      overlap: 150,\n      shift: {\n        easing: 'ease',\n        speed: 300\n      },\n      show: {\n        easing: 'ease',\n        preset: 'slide',\n        speed: 300\n      }\n    };\n    this.behaviour = {\n      autoHide: 7000,\n      onClick: false,\n      onMouseover: 'pauseAutoHide',\n      showDismissButton: true,\n      stacking: 4\n    };\n    this.position = {\n      horizontal: {\n        distance: 12,\n        position: 'left'\n      },\n      vertical: {\n        distance: 12,\n        gap: 10,\n        position: 'bottom'\n      }\n    };\n    this.theme = 'material'; // The following merges the custom options into the notifier config, respecting the already set default values\n    // This linear, more explicit and code-sizy workflow is preferred here over a recursive one (because we know the object structure)\n    // Technical sidenote: Objects are merged, other types of values simply overwritten / copied\n\n    if (customOptions.theme !== undefined) {\n      this.theme = customOptions.theme;\n    }\n\n    if (customOptions.animations !== undefined) {\n      if (customOptions.animations.enabled !== undefined) {\n        this.animations.enabled = customOptions.animations.enabled;\n      }\n\n      if (customOptions.animations.overlap !== undefined) {\n        this.animations.overlap = customOptions.animations.overlap;\n      }\n\n      if (customOptions.animations.hide !== undefined) {\n        Object.assign(this.animations.hide, customOptions.animations.hide);\n      }\n\n      if (customOptions.animations.shift !== undefined) {\n        Object.assign(this.animations.shift, customOptions.animations.shift);\n      }\n\n      if (customOptions.animations.show !== undefined) {\n        Object.assign(this.animations.show, customOptions.animations.show);\n      }\n    }\n\n    if (customOptions.behaviour !== undefined) {\n      Object.assign(this.behaviour, customOptions.behaviour);\n    }\n\n    if (customOptions.position !== undefined) {\n      if (customOptions.position.horizontal !== undefined) {\n        Object.assign(this.position.horizontal, customOptions.position.horizontal);\n      }\n\n      if (customOptions.position.vertical !== undefined) {\n        Object.assign(this.position.vertical, customOptions.position.vertical);\n      }\n    }\n  }\n\n}\n/**\n * Notifier service\n *\n * This service provides access to the public notifier API. Once injected into a component, directive, pipe, service, or any other building\n * block of an applications, it can be used to show new notifications, and hide existing ones. Internally, it transforms API calls into\n * actions, which then get thrown into the action queue - eventually being processed at the right moment.\n */\n\n\nclass NotifierService {\n  /**\n   * Constructor\n   *\n   * @param notifierQueueService Notifier queue service\n   * @param config               Notifier configuration, optionally injected as a dependency\n   */\n  constructor(notifierQueueService, config) {\n    this.queueService = notifierQueueService;\n    this.config = config;\n  }\n  /**\n   * Get the notifier configuration\n   *\n   * @returns Notifier configuration\n   */\n\n\n  getConfig() {\n    return this.config;\n  }\n  /**\n   * Get the observable for handling actions\n   *\n   * @returns Observable of NotifierAction\n   */\n\n\n  get actionStream() {\n    return this.queueService.actionStream.asObservable();\n  }\n  /**\n   * API: Show a new notification\n   *\n   * @param notificationOptions Notification options\n   */\n\n\n  show(notificationOptions) {\n    this.queueService.push({\n      payload: notificationOptions,\n      type: 'SHOW'\n    });\n  }\n  /**\n   * API: Hide a specific notification, given its ID\n   *\n   * @param notificationId ID of the notification to hide\n   */\n\n\n  hide(notificationId) {\n    this.queueService.push({\n      payload: notificationId,\n      type: 'HIDE'\n    });\n  }\n  /**\n   * API: Hide the newest notification\n   */\n\n\n  hideNewest() {\n    this.queueService.push({\n      type: 'HIDE_NEWEST'\n    });\n  }\n  /**\n   * API: Hide the oldest notification\n   */\n\n\n  hideOldest() {\n    this.queueService.push({\n      type: 'HIDE_OLDEST'\n    });\n  }\n  /**\n   * API: Hide all notifications at once\n   */\n\n\n  hideAll() {\n    this.queueService.push({\n      type: 'HIDE_ALL'\n    });\n  }\n  /**\n   * API: Shortcut for showing a new notification\n   *\n   * @param type             Type of the notification\n   * @param message          Message of the notification\n   * @param [notificationId] Unique ID for the notification (optional)\n   */\n\n\n  notify(type, message, notificationId) {\n    const notificationOptions = {\n      message,\n      type\n    };\n\n    if (notificationId !== undefined) {\n      notificationOptions.id = notificationId;\n    }\n\n    this.show(notificationOptions);\n  }\n\n}\n\nNotifierService.ɵfac = function NotifierService_Factory(t) {\n  return new (t || NotifierService)(i0.ɵɵinject(NotifierQueueService), i0.ɵɵinject(NotifierConfigToken));\n};\n\nNotifierService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NotifierService,\n  factory: NotifierService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NotifierService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: NotifierQueueService\n    }, {\n      type: NotifierConfig,\n      decorators: [{\n        type: Inject,\n        args: [NotifierConfigToken]\n      }]\n    }];\n  }, null);\n})();\n/**\n * Notifier timer service\n *\n * This service acts as a timer, needed due to the still rather limited setTimeout JavaScript API. The timer service can start and stop a\n * timer. Furthermore, it can also pause the timer at any time, and resume later on. The timer API workd promise-based.\n */\n\n\nclass NotifierTimerService {\n  /**\n   * Constructor\n   */\n  constructor() {\n    this.now = 0;\n    this.remaining = 0;\n  }\n  /**\n   * Start (or resume) the timer\n   *\n   * @param   duration Timer duration, in ms\n   * @returns          Promise, resolved once the timer finishes\n   */\n\n\n  start(duration) {\n    return new Promise(resolve => {\n      // For the first run ...\n      this.remaining = duration; // Setup, then start the timer\n\n      this.finishPromiseResolver = resolve;\n      this.continue();\n    });\n  }\n  /**\n   * Pause the timer\n   */\n\n\n  pause() {\n    clearTimeout(this.timerId);\n    this.remaining -= new Date().getTime() - this.now;\n  }\n  /**\n   * Continue the timer\n   */\n\n\n  continue() {\n    this.now = new Date().getTime();\n    this.timerId = window.setTimeout(() => {\n      this.finish();\n    }, this.remaining);\n  }\n  /**\n   * Stop the timer\n   */\n\n\n  stop() {\n    clearTimeout(this.timerId);\n    this.remaining = 0;\n  }\n  /**\n   * Finish up the timeout by resolving the timer promise\n   */\n\n\n  finish() {\n    this.finishPromiseResolver();\n  }\n\n}\n\nNotifierTimerService.ɵfac = function NotifierTimerService_Factory(t) {\n  return new (t || NotifierTimerService)();\n};\n\nNotifierTimerService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NotifierTimerService,\n  factory: NotifierTimerService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NotifierTimerService, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\n * Fade animation preset\n */\n\n\nconst fade = {\n  hide: () => {\n    return {\n      from: {\n        opacity: '1'\n      },\n      to: {\n        opacity: '0'\n      }\n    };\n  },\n  show: () => {\n    return {\n      from: {\n        opacity: '0'\n      },\n      to: {\n        opacity: '1'\n      }\n    };\n  }\n};\n/**\n * Slide animation preset\n */\n\nconst slide = {\n  hide: notification => {\n    // Prepare variables\n    const config = notification.component.getConfig();\n    const shift = notification.component.getShift();\n    let from;\n    let to; // Configure variables, depending on configuration and component\n\n    if (config.position.horizontal.position === 'left') {\n      from = {\n        transform: `translate3d( 0, ${shift}px, 0 )`\n      };\n      to = {\n        transform: `translate3d( calc( -100% - ${config.position.horizontal.distance}px - 10px ), ${shift}px, 0 )`\n      };\n    } else if (config.position.horizontal.position === 'right') {\n      from = {\n        transform: `translate3d( 0, ${shift}px, 0 )`\n      };\n      to = {\n        transform: `translate3d( calc( 100% + ${config.position.horizontal.distance}px + 10px ), ${shift}px, 0 )`\n      };\n    } else {\n      let horizontalPosition;\n\n      if (config.position.vertical.position === 'top') {\n        horizontalPosition = `calc( -100% - ${config.position.horizontal.distance}px - 10px )`;\n      } else {\n        horizontalPosition = `calc( 100% + ${config.position.horizontal.distance}px + 10px )`;\n      }\n\n      from = {\n        transform: `translate3d( -50%, ${shift}px, 0 )`\n      };\n      to = {\n        transform: `translate3d( -50%, ${horizontalPosition}, 0 )`\n      };\n    } // Done\n\n\n    return {\n      from,\n      to\n    };\n  },\n  show: notification => {\n    // Prepare variables\n    const config = notification.component.getConfig();\n    let from;\n    let to; // Configure variables, depending on configuration and component\n\n    if (config.position.horizontal.position === 'left') {\n      from = {\n        transform: `translate3d( calc( -100% - ${config.position.horizontal.distance}px - 10px ), 0, 0 )`\n      };\n      to = {\n        transform: 'translate3d( 0, 0, 0 )'\n      };\n    } else if (config.position.horizontal.position === 'right') {\n      from = {\n        transform: `translate3d( calc( 100% + ${config.position.horizontal.distance}px + 10px ), 0, 0 )`\n      };\n      to = {\n        transform: 'translate3d( 0, 0, 0 )'\n      };\n    } else {\n      let horizontalPosition;\n\n      if (config.position.vertical.position === 'top') {\n        horizontalPosition = `calc( -100% - ${config.position.horizontal.distance}px - 10px )`;\n      } else {\n        horizontalPosition = `calc( 100% + ${config.position.horizontal.distance}px + 10px )`;\n      }\n\n      from = {\n        transform: `translate3d( -50%, ${horizontalPosition}, 0 )`\n      };\n      to = {\n        transform: 'translate3d( -50%, 0, 0 )'\n      };\n    } // Done\n\n\n    return {\n      from,\n      to\n    };\n  }\n};\n/**\n * Notifier animation service\n */\n\nclass NotifierAnimationService {\n  /**\n   * Constructor\n   */\n  constructor() {\n    this.animationPresets = {\n      fade,\n      slide\n    };\n  }\n  /**\n   * Get animation data\n   *\n   * This method generates all data the Web Animations API needs to animate our notification. The result depends on both the animation\n   * direction (either in or out) as well as the notifications (and its attributes) itself.\n   *\n   * @param   direction    Animation direction, either in or out\n   * @param   notification Notification the animation data should be generated for\n   * @returns Animation information\n   */\n\n\n  getAnimationData(direction, notification) {\n    // Get all necessary animation data\n    let keyframes;\n    let duration;\n    let easing;\n\n    if (direction === 'show') {\n      keyframes = this.animationPresets[notification.component.getConfig().animations.show.preset].show(notification);\n      duration = notification.component.getConfig().animations.show.speed;\n      easing = notification.component.getConfig().animations.show.easing;\n    } else {\n      keyframes = this.animationPresets[notification.component.getConfig().animations.hide.preset].hide(notification);\n      duration = notification.component.getConfig().animations.hide.speed;\n      easing = notification.component.getConfig().animations.hide.easing;\n    } // Build and return animation data\n\n\n    return {\n      keyframes: [keyframes.from, keyframes.to],\n      options: {\n        duration,\n        easing,\n        fill: 'forwards' // Keep the newly painted state after the animation finished\n\n      }\n    };\n  }\n\n}\n\nNotifierAnimationService.ɵfac = function NotifierAnimationService_Factory(t) {\n  return new (t || NotifierAnimationService)();\n};\n\nNotifierAnimationService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NotifierAnimationService,\n  factory: NotifierAnimationService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NotifierAnimationService, [{\n    type: Injectable\n  }], function () {\n    return [];\n  }, null);\n})();\n/**\n * Notifier notification component\n * -------------------------------\n * This component is responsible for actually displaying the notification on screen. In addition, it's able to show and hide this\n * notification, in particular to animate this notification in and out, as well as shift (move) this notification vertically around.\n * Furthermore, the notification component handles all interactions the user has with this notification / component, such as clicks and\n * mouse movements.\n */\n\n\nclass NotifierNotificationComponent {\n  /**\n   * Constructor\n   *\n   * @param elementRef               Reference to the component's element\n   * @param renderer                 Angular renderer\n   * @param notifierService          Notifier service\n   * @param notifierTimerService     Notifier timer service\n   * @param notifierAnimationService Notifier animation service\n   */\n  constructor(elementRef, renderer, notifierService, notifierTimerService, notifierAnimationService) {\n    this.config = notifierService.getConfig();\n    this.ready = new EventEmitter();\n    this.dismiss = new EventEmitter();\n    this.timerService = notifierTimerService;\n    this.animationService = notifierAnimationService;\n    this.renderer = renderer;\n    this.element = elementRef.nativeElement;\n    this.elementShift = 0;\n  }\n  /**\n   * Component after view init lifecycle hook, setts up the component and then emits the ready event\n   */\n\n\n  ngAfterViewInit() {\n    this.setup();\n    this.elementHeight = this.element.offsetHeight;\n    this.elementWidth = this.element.offsetWidth;\n    this.ready.emit(this);\n  }\n  /**\n   * Get the notifier config\n   *\n   * @returns Notifier configuration\n   */\n\n\n  getConfig() {\n    return this.config;\n  }\n  /**\n   * Get notification element height (in px)\n   *\n   * @returns Notification element height (in px)\n   */\n\n\n  getHeight() {\n    return this.elementHeight;\n  }\n  /**\n   * Get notification element width (in px)\n   *\n   * @returns Notification element height (in px)\n   */\n\n\n  getWidth() {\n    return this.elementWidth;\n  }\n  /**\n   * Get notification shift offset (in px)\n   *\n   * @returns Notification element shift offset (in px)\n   */\n\n\n  getShift() {\n    return this.elementShift;\n  }\n  /**\n   * Show (animate in) this notification\n   *\n   * @returns Promise, resolved when done\n   */\n\n\n  show() {\n    return new Promise(resolve => {\n      // Are animations enabled?\n      if (this.config.animations.enabled && this.config.animations.show.speed > 0) {\n        // Get animation data\n        const animationData = this.animationService.getAnimationData('show', this.notification); // Set initial styles (styles before animation), prevents quick flicker when animation starts\n\n        const animatedProperties = Object.keys(animationData.keyframes[0]);\n\n        for (let i = animatedProperties.length - 1; i >= 0; i--) {\n          this.renderer.setStyle(this.element, animatedProperties[i], animationData.keyframes[0][animatedProperties[i]]);\n        } // Animate notification in\n\n\n        this.renderer.setStyle(this.element, 'visibility', 'visible');\n        const animation = this.element.animate(animationData.keyframes, animationData.options);\n\n        animation.onfinish = () => {\n          this.startAutoHideTimer();\n          resolve(); // Done\n        };\n      } else {\n        // Show notification\n        this.renderer.setStyle(this.element, 'visibility', 'visible');\n        this.startAutoHideTimer();\n        resolve(); // Done\n      }\n    });\n  }\n  /**\n   * Hide (animate out) this notification\n   *\n   * @returns Promise, resolved when done\n   */\n\n\n  hide() {\n    return new Promise(resolve => {\n      this.stopAutoHideTimer(); // Are animations enabled?\n\n      if (this.config.animations.enabled && this.config.animations.hide.speed > 0) {\n        const animationData = this.animationService.getAnimationData('hide', this.notification);\n        const animation = this.element.animate(animationData.keyframes, animationData.options);\n\n        animation.onfinish = () => {\n          resolve(); // Done\n        };\n      } else {\n        resolve(); // Done\n      }\n    });\n  }\n  /**\n   * Shift (move) this notification\n   *\n   * @param   distance         Distance to shift (in px)\n   * @param   shiftToMakePlace Flag, defining in which direction to shift\n   * @returns Promise, resolved when done\n   */\n\n\n  shift(distance, shiftToMakePlace) {\n    return new Promise(resolve => {\n      // Calculate new position (position after the shift)\n      let newElementShift;\n\n      if (this.config.position.vertical.position === 'top' && shiftToMakePlace || this.config.position.vertical.position === 'bottom' && !shiftToMakePlace) {\n        newElementShift = this.elementShift + distance + this.config.position.vertical.gap;\n      } else {\n        newElementShift = this.elementShift - distance - this.config.position.vertical.gap;\n      }\n\n      const horizontalPosition = this.config.position.horizontal.position === 'middle' ? '-50%' : '0'; // Are animations enabled?\n\n      if (this.config.animations.enabled && this.config.animations.shift.speed > 0) {\n        const animationData = {\n          // TODO: Extract into animation service\n          keyframes: [{\n            transform: `translate3d( ${horizontalPosition}, ${this.elementShift}px, 0 )`\n          }, {\n            transform: `translate3d( ${horizontalPosition}, ${newElementShift}px, 0 )`\n          }],\n          options: {\n            duration: this.config.animations.shift.speed,\n            easing: this.config.animations.shift.easing,\n            fill: 'forwards'\n          }\n        };\n        this.elementShift = newElementShift;\n        const animation = this.element.animate(animationData.keyframes, animationData.options);\n\n        animation.onfinish = () => {\n          resolve(); // Done\n        };\n      } else {\n        this.renderer.setStyle(this.element, 'transform', `translate3d( ${horizontalPosition}, ${newElementShift}px, 0 )`);\n        this.elementShift = newElementShift;\n        resolve(); // Done\n      }\n    });\n  }\n  /**\n   * Handle click on dismiss button\n   */\n\n\n  onClickDismiss() {\n    this.dismiss.emit(this.notification.id);\n  }\n  /**\n   * Handle mouseover over notification area\n   */\n\n\n  onNotificationMouseover() {\n    if (this.config.behaviour.onMouseover === 'pauseAutoHide') {\n      this.pauseAutoHideTimer();\n    } else if (this.config.behaviour.onMouseover === 'resetAutoHide') {\n      this.stopAutoHideTimer();\n    }\n  }\n  /**\n   * Handle mouseout from notification area\n   */\n\n\n  onNotificationMouseout() {\n    if (this.config.behaviour.onMouseover === 'pauseAutoHide') {\n      this.continueAutoHideTimer();\n    } else if (this.config.behaviour.onMouseover === 'resetAutoHide') {\n      this.startAutoHideTimer();\n    }\n  }\n  /**\n   * Handle click on notification area\n   */\n\n\n  onNotificationClick() {\n    if (this.config.behaviour.onClick === 'hide') {\n      this.onClickDismiss();\n    }\n  }\n  /**\n   * Start the auto hide timer (if enabled)\n   */\n\n\n  startAutoHideTimer() {\n    if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n      this.timerService.start(this.config.behaviour.autoHide).then(() => {\n        this.onClickDismiss();\n      });\n    }\n  }\n  /**\n   * Pause the auto hide timer (if enabled)\n   */\n\n\n  pauseAutoHideTimer() {\n    if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n      this.timerService.pause();\n    }\n  }\n  /**\n   * Continue the auto hide timer (if enabled)\n   */\n\n\n  continueAutoHideTimer() {\n    if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n      this.timerService.continue();\n    }\n  }\n  /**\n   * Stop the auto hide timer (if enabled)\n   */\n\n\n  stopAutoHideTimer() {\n    if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n      this.timerService.stop();\n    }\n  }\n  /**\n   * Initial notification setup\n   */\n\n\n  setup() {\n    // Set start position (initially the exact same for every new notification)\n    if (this.config.position.horizontal.position === 'left') {\n      this.renderer.setStyle(this.element, 'left', `${this.config.position.horizontal.distance}px`);\n    } else if (this.config.position.horizontal.position === 'right') {\n      this.renderer.setStyle(this.element, 'right', `${this.config.position.horizontal.distance}px`);\n    } else {\n      this.renderer.setStyle(this.element, 'left', '50%'); // Let's get the GPU handle some work as well (#perfmatters)\n\n      this.renderer.setStyle(this.element, 'transform', 'translate3d( -50%, 0, 0 )');\n    }\n\n    if (this.config.position.vertical.position === 'top') {\n      this.renderer.setStyle(this.element, 'top', `${this.config.position.vertical.distance}px`);\n    } else {\n      this.renderer.setStyle(this.element, 'bottom', `${this.config.position.vertical.distance}px`);\n    } // Add classes (responsible for visual design)\n\n\n    this.renderer.addClass(this.element, `notifier__notification--${this.notification.type}`);\n    this.renderer.addClass(this.element, `notifier__notification--${this.config.theme}`);\n  }\n\n}\n\nNotifierNotificationComponent.ɵfac = function NotifierNotificationComponent_Factory(t) {\n  return new (t || NotifierNotificationComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(NotifierService), i0.ɵɵdirectiveInject(NotifierTimerService), i0.ɵɵdirectiveInject(NotifierAnimationService));\n};\n\nNotifierNotificationComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: NotifierNotificationComponent,\n  selectors: [[\"notifier-notification\"]],\n  hostAttrs: [1, \"notifier__notification\"],\n  hostBindings: function NotifierNotificationComponent_HostBindings(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵlistener(\"click\", function NotifierNotificationComponent_click_HostBindingHandler() {\n        return ctx.onNotificationClick();\n      })(\"mouseout\", function NotifierNotificationComponent_mouseout_HostBindingHandler() {\n        return ctx.onNotificationMouseout();\n      })(\"mouseover\", function NotifierNotificationComponent_mouseover_HostBindingHandler() {\n        return ctx.onNotificationMouseover();\n      });\n    }\n  },\n  inputs: {\n    notification: \"notification\"\n  },\n  outputs: {\n    ready: \"ready\",\n    dismiss: \"dismiss\"\n  },\n  features: [i0.ɵɵProvidersFeature([// We provide the timer to the component's local injector, so that every notification components gets its own\n  // instance of the timer service, thus running their timers independently from each other\n  NotifierTimerService])],\n  decls: 3,\n  vars: 2,\n  consts: [[3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\", 4, \"ngIf\", \"ngIfElse\"], [\"predefinedNotification\", \"\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"notifier__notification-message\"], [\"class\", \"notifier__notification-button\", \"type\", \"button\", \"title\", \"dismiss\", 3, \"click\", 4, \"ngIf\"], [\"type\", \"button\", \"title\", \"dismiss\", 1, \"notifier__notification-button\", 3, \"click\"], [\"viewBox\", \"0 0 24 24\", \"width\", \"20\", \"height\", \"20\", 1, \"notifier__notification-button-icon\"], [\"d\", \"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\"]],\n  template: function NotifierNotificationComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵtemplate(0, NotifierNotificationComponent_ng_container_0_Template, 1, 4, \"ng-container\", 0);\n      i0.ɵɵtemplate(1, NotifierNotificationComponent_ng_template_1_Template, 3, 2, \"ng-template\", null, 1, i0.ɵɵtemplateRefExtractor);\n    }\n\n    if (rf & 2) {\n      const _r1 = i0.ɵɵreference(2);\n\n      i0.ɵɵproperty(\"ngIf\", ctx.notification.template)(\"ngIfElse\", _r1);\n    }\n  },\n  directives: [i4.NgIf, i4.NgTemplateOutlet],\n  encapsulation: 2,\n  changeDetection: 0\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NotifierNotificationComponent, [{\n    type: Component,\n    args: [{\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      host: {\n        '(click)': 'onNotificationClick()',\n        '(mouseout)': 'onNotificationMouseout()',\n        '(mouseover)': 'onNotificationMouseover()',\n        class: 'notifier__notification'\n      },\n      providers: [// We provide the timer to the component's local injector, so that every notification components gets its own\n      // instance of the timer service, thus running their timers independently from each other\n      NotifierTimerService],\n      selector: 'notifier-notification',\n      template: \"<ng-container\\n  *ngIf=\\\"notification.template; else predefinedNotification\\\"\\n  [ngTemplateOutlet]=\\\"notification.template\\\"\\n  [ngTemplateOutletContext]=\\\"{ notification: notification }\\\"\\n>\\n</ng-container>\\n\\n<ng-template #predefinedNotification>\\n  <p class=\\\"notifier__notification-message\\\">{{ notification.message }}</p>\\n  <button\\n    class=\\\"notifier__notification-button\\\"\\n    type=\\\"button\\\"\\n    title=\\\"dismiss\\\"\\n    *ngIf=\\\"config.behaviour.showDismissButton\\\"\\n    (click)=\\\"onClickDismiss()\\\"\\n  >\\n    <svg class=\\\"notifier__notification-button-icon\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"20\\\" height=\\\"20\\\">\\n      <path d=\\\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\\\" />\\n    </svg>\\n  </button>\\n</ng-template>\\n\"\n    }]\n  }], function () {\n    return [{\n      type: i0.ElementRef\n    }, {\n      type: i0.Renderer2\n    }, {\n      type: NotifierService\n    }, {\n      type: NotifierTimerService\n    }, {\n      type: NotifierAnimationService\n    }];\n  }, {\n    notification: [{\n      type: Input\n    }],\n    ready: [{\n      type: Output\n    }],\n    dismiss: [{\n      type: Output\n    }]\n  });\n})();\n/**\n * Notifier container component\n * ----------------------------\n * This component acts as a wrapper for all notification components; consequently, it is responsible for creating a new notification\n * component and removing an existing notification component. Being more precicely, it also handles side effects of those actions, such as\n * shifting or even completely removing other notifications as well. Overall, this components handles actions coming from the queue service\n * by subscribing to its action stream.\n *\n * Technical sidenote:\n * This component has to be used somewhere in an application to work; it will not inject and create itself automatically, primarily in order\n * to not break the Angular AoT compilation. Moreover, this component (and also the notification components) set their change detection\n * strategy onPush, which means that we handle change detection manually in order to get the best performance. (#perfmatters)\n */\n\n\nclass NotifierContainerComponent {\n  /**\n   * Constructor\n   *\n   * @param changeDetector       Change detector, used for manually triggering change detection runs\n   * @param notifierQueueService Notifier queue service\n   * @param notifierService      Notifier service\n   */\n  constructor(changeDetector, notifierQueueService, notifierService) {\n    this.changeDetector = changeDetector;\n    this.queueService = notifierQueueService;\n    this.config = notifierService.getConfig();\n    this.notifications = []; // Connects this component up to the action queue, then handle incoming actions\n\n    this.queueServiceSubscription = this.queueService.actionStream.subscribe(action => {\n      this.handleAction(action).then(() => {\n        this.queueService.continue();\n      });\n    });\n  }\n  /**\n   * Component destroyment lifecycle hook, cleans up the observable subsciption\n   */\n\n\n  ngOnDestroy() {\n    if (this.queueServiceSubscription) {\n      this.queueServiceSubscription.unsubscribe();\n    }\n  }\n  /**\n   * Notification identifier, used as the ngFor trackby function\n   *\n   * @param   index        Index\n   * @param   notification Notifier notification\n   * @returns Notification ID as the unique identnfier\n   */\n\n\n  identifyNotification(index, notification) {\n    return notification.id;\n  }\n  /**\n   * Event handler, handles clicks on notification dismiss buttons\n   *\n   * @param notificationId ID of the notification to dismiss\n   */\n\n\n  onNotificationDismiss(notificationId) {\n    this.queueService.push({\n      payload: notificationId,\n      type: 'HIDE'\n    });\n  }\n  /**\n   * Event handler, handles notification ready events\n   *\n   * @param notificationComponent Notification component reference\n   */\n\n\n  onNotificationReady(notificationComponent) {\n    const currentNotification = this.notifications[this.notifications.length - 1]; // Get the latest notification\n\n    currentNotification.component = notificationComponent; // Save the new omponent reference\n\n    this.continueHandleShowAction(currentNotification); // Continue with handling the show action\n  }\n  /**\n   * Handle incoming actions by mapping action types to methods, and then running them\n   *\n   * @param   action Action object\n   * @returns Promise, resolved when done\n   */\n\n\n  handleAction(action) {\n    switch (action.type // TODO: Maybe a map (actionType -> class method) is a cleaner solution here?\n    ) {\n      case 'SHOW':\n        return this.handleShowAction(action);\n\n      case 'HIDE':\n        return this.handleHideAction(action);\n\n      case 'HIDE_OLDEST':\n        return this.handleHideOldestAction(action);\n\n      case 'HIDE_NEWEST':\n        return this.handleHideNewestAction(action);\n\n      case 'HIDE_ALL':\n        return this.handleHideAllAction();\n\n      default:\n        return new Promise(resolve => {\n          resolve(); // Ignore unknown action types\n        });\n    }\n  }\n  /**\n   * Show a new notification\n   *\n   * We simply add the notification to the list, and then wait until its properly initialized / created / rendered.\n   *\n   * @param   action Action object\n   * @returns Promise, resolved when done\n   */\n\n\n  handleShowAction(action) {\n    return new Promise(resolve => {\n      this.tempPromiseResolver = resolve; // Save the promise resolve function so that it can be called later on by another method\n\n      this.addNotificationToList(new NotifierNotification(action.payload));\n    });\n  }\n  /**\n   * Continue to show a new notification (after the notification components is initialized / created / rendered).\n   *\n   * If this is the first (and thus only) notification, we can simply show it. Otherwhise, if stacking is disabled (or a low value), we\n   * switch out notifications, in particular we hide the existing one, and then show our new one. Yet, if stacking is enabled, we first\n   * shift all older notifications, and then show our new notification. In addition, if there are too many notification on the screen,\n   * we hide the oldest one first. Furthermore, if configured, animation overlapping is applied.\n   *\n   * @param notification New notification to show\n   */\n\n\n  continueHandleShowAction(notification) {\n    // First (which means only one) notification in the list?\n    const numberOfNotifications = this.notifications.length;\n\n    if (numberOfNotifications === 1) {\n      notification.component.show().then(this.tempPromiseResolver); // Done\n    } else {\n      const implicitStackingLimit = 2; // Stacking enabled? (stacking value below 2 means stacking is disabled)\n\n      if (this.config.behaviour.stacking === false || this.config.behaviour.stacking < implicitStackingLimit) {\n        this.notifications[0].component.hide().then(() => {\n          this.removeNotificationFromList(this.notifications[0]);\n          notification.component.show().then(this.tempPromiseResolver); // Done\n        });\n      } else {\n        const stepPromises = []; // Are there now too many notifications?\n\n        if (numberOfNotifications > this.config.behaviour.stacking) {\n          const oldNotifications = this.notifications.slice(1, numberOfNotifications - 1); // Are animations enabled?\n\n          if (this.config.animations.enabled) {\n            // Is animation overlap enabled?\n            if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n              stepPromises.push(this.notifications[0].component.hide());\n              setTimeout(() => {\n                stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n              }, this.config.animations.hide.speed - this.config.animations.overlap);\n              setTimeout(() => {\n                stepPromises.push(notification.component.show());\n              }, this.config.animations.hide.speed + this.config.animations.shift.speed - this.config.animations.overlap);\n            } else {\n              stepPromises.push(new Promise(resolve => {\n                this.notifications[0].component.hide().then(() => {\n                  this.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(() => {\n                    notification.component.show().then(resolve);\n                  });\n                });\n              }));\n            }\n          } else {\n            stepPromises.push(this.notifications[0].component.hide());\n            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n            stepPromises.push(notification.component.show());\n          }\n        } else {\n          const oldNotifications = this.notifications.slice(0, numberOfNotifications - 1); // Are animations enabled?\n\n          if (this.config.animations.enabled) {\n            // Is animation overlap enabled?\n            if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n              stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n              setTimeout(() => {\n                stepPromises.push(notification.component.show());\n              }, this.config.animations.shift.speed - this.config.animations.overlap);\n            } else {\n              stepPromises.push(new Promise(resolve => {\n                this.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(() => {\n                  notification.component.show().then(resolve);\n                });\n              }));\n            }\n          } else {\n            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n            stepPromises.push(notification.component.show());\n          }\n        }\n\n        Promise.all(stepPromises).then(() => {\n          if (numberOfNotifications > this.config.behaviour.stacking) {\n            this.removeNotificationFromList(this.notifications[0]);\n          }\n\n          this.tempPromiseResolver();\n        }); // Done\n      }\n    }\n  }\n  /**\n   * Hide an existing notification\n   *\n   * Fist, we skip everything if there are no notifications at all, or the given notification does not exist. Then, we hide the given\n   * notification. If there exist older notifications, we then shift them around to fill the gap. Once both hiding the given notification\n   * and shifting the older notificaitons is done, the given notification gets finally removed (from the DOM).\n   *\n   * @param   action Action object, payload contains the notification ID\n   * @returns Promise, resolved when done\n   */\n\n\n  handleHideAction(action) {\n    return new Promise(resolve => {\n      const stepPromises = []; // Does the notification exist / are there even any notifications? (let's prevent accidential errors)\n\n      const notification = this.findNotificationById(action.payload);\n\n      if (notification === undefined) {\n        resolve();\n        return;\n      } // Get older notifications\n\n\n      const notificationIndex = this.findNotificationIndexById(action.payload);\n\n      if (notificationIndex === undefined) {\n        resolve();\n        return;\n      }\n\n      const oldNotifications = this.notifications.slice(0, notificationIndex); // Do older notifications exist, and thus do we need to shift other notifications as a consequence?\n\n      if (oldNotifications.length > 0) {\n        // Are animations enabled?\n        if (this.config.animations.enabled && this.config.animations.hide.speed > 0) {\n          // Is animation overlap enabled?\n          if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n            stepPromises.push(notification.component.hide());\n            setTimeout(() => {\n              stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n            }, this.config.animations.hide.speed - this.config.animations.overlap);\n          } else {\n            notification.component.hide().then(() => {\n              stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n            });\n          }\n        } else {\n          stepPromises.push(notification.component.hide());\n          stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n        }\n      } else {\n        stepPromises.push(notification.component.hide());\n      } // Wait until both hiding and shifting is done, then remove the notification from the list\n\n\n      Promise.all(stepPromises).then(() => {\n        this.removeNotificationFromList(notification);\n        resolve(); // Done\n      });\n    });\n  }\n  /**\n   * Hide the oldest notification (bridge to handleHideAction)\n   *\n   * @param   action Action object\n   * @returns Promise, resolved when done\n   */\n\n\n  handleHideOldestAction(action) {\n    // Are there any notifications? (prevent accidential errors)\n    if (this.notifications.length === 0) {\n      return new Promise(resolve => {\n        resolve();\n      }); // Done\n    } else {\n      action.payload = this.notifications[0].id;\n      return this.handleHideAction(action);\n    }\n  }\n  /**\n   * Hide the newest notification (bridge to handleHideAction)\n   *\n   * @param   action Action object\n   * @returns Promise, resolved when done\n   */\n\n\n  handleHideNewestAction(action) {\n    // Are there any notifications? (prevent accidential errors)\n    if (this.notifications.length === 0) {\n      return new Promise(resolve => {\n        resolve();\n      }); // Done\n    } else {\n      action.payload = this.notifications[this.notifications.length - 1].id;\n      return this.handleHideAction(action);\n    }\n  }\n  /**\n   * Hide all notifications at once\n   *\n   * @returns Promise, resolved when done\n   */\n\n\n  handleHideAllAction() {\n    return new Promise(resolve => {\n      // Are there any notifications? (prevent accidential errors)\n      const numberOfNotifications = this.notifications.length;\n\n      if (numberOfNotifications === 0) {\n        resolve(); // Done\n\n        return;\n      } // Are animations enabled?\n\n\n      if (this.config.animations.enabled && this.config.animations.hide.speed > 0 && this.config.animations.hide.offset !== false && this.config.animations.hide.offset > 0) {\n        for (let i = numberOfNotifications - 1; i >= 0; i--) {\n          const animationOffset = this.config.position.vertical.position === 'top' ? numberOfNotifications - 1 : i;\n          setTimeout(() => {\n            this.notifications[i].component.hide().then(() => {\n              // Are we done here, was this the last notification to be hidden?\n              if (this.config.position.vertical.position === 'top' && i === 0 || this.config.position.vertical.position === 'bottom' && i === numberOfNotifications - 1) {\n                this.removeAllNotificationsFromList();\n                resolve(); // Done\n              }\n            });\n          }, this.config.animations.hide.offset * animationOffset);\n        }\n      } else {\n        const stepPromises = [];\n\n        for (let i = numberOfNotifications - 1; i >= 0; i--) {\n          stepPromises.push(this.notifications[i].component.hide());\n        }\n\n        Promise.all(stepPromises).then(() => {\n          this.removeAllNotificationsFromList();\n          resolve(); // Done\n        });\n      }\n    });\n  }\n  /**\n   * Shift multiple notifications at once\n   *\n   * @param   notifications List containing the notifications to be shifted\n   * @param   distance      Distance to shift (in px)\n   * @param   toMakePlace   Flag, defining in which direciton to shift\n   * @returns Promise, resolved when done\n   */\n\n\n  shiftNotifications(notifications, distance, toMakePlace) {\n    return new Promise(resolve => {\n      // Are there any notifications to shift?\n      if (notifications.length === 0) {\n        resolve();\n        return;\n      }\n\n      const notificationPromises = [];\n\n      for (let i = notifications.length - 1; i >= 0; i--) {\n        notificationPromises.push(notifications[i].component.shift(distance, toMakePlace));\n      }\n\n      Promise.all(notificationPromises).then(resolve); // Done\n    });\n  }\n  /**\n   * Add a new notification to the list of notifications (triggers change detection)\n   *\n   * @param notification Notification to add to the list of notifications\n   */\n\n\n  addNotificationToList(notification) {\n    this.notifications.push(notification);\n    this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n  }\n  /**\n   * Remove an existing notification from the list of notifications (triggers change detection)\n   *\n   * @param notification Notification to be removed from the list of notifications\n   */\n\n\n  removeNotificationFromList(notification) {\n    this.notifications = this.notifications.filter(item => item.component !== notification.component);\n    this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n  }\n  /**\n   * Remove all notifications from the list (triggers change detection)\n   */\n\n\n  removeAllNotificationsFromList() {\n    this.notifications = [];\n    this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n  }\n  /**\n   * Helper: Find a notification in the notification list by a given notification ID\n   *\n   * @param   notificationId Notification ID, used for finding notification\n   * @returns Notification, undefined if not found\n   */\n\n\n  findNotificationById(notificationId) {\n    return this.notifications.find(currentNotification => currentNotification.id === notificationId);\n  }\n  /**\n   * Helper: Find a notification's index by a given notification ID\n   *\n   * @param   notificationId Notification ID, used for finding a notification's index\n   * @returns Notification index, undefined if not found\n   */\n\n\n  findNotificationIndexById(notificationId) {\n    const notificationIndex = this.notifications.findIndex(currentNotification => currentNotification.id === notificationId);\n    return notificationIndex !== -1 ? notificationIndex : undefined;\n  }\n\n}\n\nNotifierContainerComponent.ɵfac = function NotifierContainerComponent_Factory(t) {\n  return new (t || NotifierContainerComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(NotifierQueueService), i0.ɵɵdirectiveInject(NotifierService));\n};\n\nNotifierContainerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n  type: NotifierContainerComponent,\n  selectors: [[\"notifier-container\"]],\n  hostAttrs: [1, \"notifier__container\"],\n  decls: 2,\n  vars: 2,\n  consts: [[1, \"notifier__container-list\"], [\"class\", \"notifier__container-list-item\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [1, \"notifier__container-list-item\"], [3, \"notification\", \"ready\", \"dismiss\"]],\n  template: function NotifierContainerComponent_Template(rf, ctx) {\n    if (rf & 1) {\n      i0.ɵɵelementStart(0, \"ul\", 0);\n      i0.ɵɵtemplate(1, NotifierContainerComponent_li_1_Template, 2, 1, \"li\", 1);\n      i0.ɵɵelementEnd();\n    }\n\n    if (rf & 2) {\n      i0.ɵɵadvance(1);\n      i0.ɵɵproperty(\"ngForOf\", ctx.notifications)(\"ngForTrackBy\", ctx.identifyNotification);\n    }\n  },\n  directives: [NotifierNotificationComponent, i4.NgForOf],\n  encapsulation: 2,\n  changeDetection: 0\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NotifierContainerComponent, [{\n    type: Component,\n    args: [{\n      changeDetection: ChangeDetectionStrategy.OnPush,\n      host: {\n        class: 'notifier__container'\n      },\n      selector: 'notifier-container',\n      template: \"<ul class=\\\"notifier__container-list\\\">\\n  <li class=\\\"notifier__container-list-item\\\" *ngFor=\\\"let notification of notifications; trackBy: identifyNotification\\\">\\n    <notifier-notification [notification]=\\\"notification\\\" (ready)=\\\"onNotificationReady($event)\\\" (dismiss)=\\\"onNotificationDismiss($event)\\\">\\n    </notifier-notification>\\n  </li>\\n</ul>\\n\"\n    }]\n  }], function () {\n    return [{\n      type: i0.ChangeDetectorRef\n    }, {\n      type: NotifierQueueService\n    }, {\n      type: NotifierService\n    }];\n  }, null);\n})();\n/**\n * Factory for a notifier configuration with custom options\n *\n * Sidenote:\n * Required as Angular AoT compilation cannot handle dynamic functions; see <https://github.com/angular/angular/issues/11262>.\n *\n * @param   options - Custom notifier options\n * @returns - Notifier configuration as result\n */\n\n\nfunction notifierCustomConfigFactory(options) {\n  return new NotifierConfig(options);\n}\n/**\n * Factory for a notifier configuration with default options\n *\n * Sidenote:\n * Required as Angular AoT compilation cannot handle dynamic functions; see <https://github.com/angular/angular/issues/11262>.\n *\n * @returns - Notifier configuration as result\n */\n\n\nfunction notifierDefaultConfigFactory() {\n  return new NotifierConfig({});\n}\n/**\n * Notifier module\n */\n\n\nclass NotifierModule {\n  /**\n   * Setup the notifier module with custom providers, in this case with a custom configuration based on the givne options\n   *\n   * @param   [options={}] - Custom notifier options\n   * @returns - Notifier module with custom providers\n   */\n  static withConfig(options = {}) {\n    return {\n      ngModule: NotifierModule,\n      providers: [// Provide the options itself upfront (as we need to inject them as dependencies -- see below)\n      {\n        provide: NotifierOptionsToken,\n        useValue: options\n      }, // Provide a custom notifier configuration, based on the given notifier options\n      {\n        deps: [NotifierOptionsToken],\n        provide: NotifierConfigToken,\n        useFactory: notifierCustomConfigFactory\n      }]\n    };\n  }\n\n}\n\nNotifierModule.ɵfac = function NotifierModule_Factory(t) {\n  return new (t || NotifierModule)();\n};\n\nNotifierModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: NotifierModule\n});\nNotifierModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  providers: [NotifierAnimationService, NotifierService, NotifierQueueService, // Provide the default notifier configuration if just the module is imported\n  {\n    provide: NotifierConfigToken,\n    useFactory: notifierDefaultConfigFactory\n  }],\n  imports: [[CommonModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NotifierModule, [{\n    type: NgModule,\n    args: [{\n      declarations: [NotifierContainerComponent, NotifierNotificationComponent],\n      exports: [NotifierContainerComponent],\n      imports: [CommonModule],\n      providers: [NotifierAnimationService, NotifierService, NotifierQueueService, // Provide the default notifier configuration if just the module is imported\n      {\n        provide: NotifierConfigToken,\n        useFactory: notifierDefaultConfigFactory\n      }]\n    }]\n  }], null, null);\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NotifierConfig, NotifierConfigToken, NotifierContainerComponent, NotifierModule, NotifierNotificationComponent, NotifierOptionsToken, NotifierService, notifierCustomConfigFactory, notifierDefaultConfigFactory };","map":{"version":3,"sources":["/Users/robimarkac/Development/openmoneymarket-frontend/node_modules/angular-notifier/fesm2015/angular-notifier.mjs"],"names":["i0","Injectable","InjectionToken","Inject","EventEmitter","Component","ChangeDetectionStrategy","Input","Output","NgModule","Subject","i4","CommonModule","NotifierNotification","constructor","options","template","Object","assign","id","undefined","Date","getTime","NotifierQueueService","actionStream","actionQueue","isActionInProgress","push","action","tryToRunNextAction","continue","length","next","shift","ɵfac","ɵprov","type","NotifierOptionsToken","NotifierConfigToken","NotifierConfig","customOptions","animations","enabled","hide","easing","offset","preset","speed","overlap","show","behaviour","autoHide","onClick","onMouseover","showDismissButton","stacking","position","horizontal","distance","vertical","gap","theme","NotifierService","notifierQueueService","config","queueService","getConfig","asObservable","notificationOptions","payload","notificationId","hideNewest","hideOldest","hideAll","notify","message","decorators","args","NotifierTimerService","now","remaining","start","duration","Promise","resolve","finishPromiseResolver","pause","clearTimeout","timerId","window","setTimeout","finish","stop","fade","from","opacity","to","slide","notification","component","getShift","transform","horizontalPosition","NotifierAnimationService","animationPresets","getAnimationData","direction","keyframes","fill","NotifierNotificationComponent","elementRef","renderer","notifierService","notifierTimerService","notifierAnimationService","ready","dismiss","timerService","animationService","element","nativeElement","elementShift","ngAfterViewInit","setup","elementHeight","offsetHeight","elementWidth","offsetWidth","emit","getHeight","getWidth","animationData","animatedProperties","keys","i","setStyle","animation","animate","onfinish","startAutoHideTimer","stopAutoHideTimer","shiftToMakePlace","newElementShift","onClickDismiss","onNotificationMouseover","pauseAutoHideTimer","onNotificationMouseout","continueAutoHideTimer","onNotificationClick","then","addClass","ElementRef","Renderer2","ɵcmp","NgIf","NgTemplateOutlet","changeDetection","OnPush","host","class","providers","selector","NotifierContainerComponent","changeDetector","notifications","queueServiceSubscription","subscribe","handleAction","ngOnDestroy","unsubscribe","identifyNotification","index","onNotificationDismiss","onNotificationReady","notificationComponent","currentNotification","continueHandleShowAction","handleShowAction","handleHideAction","handleHideOldestAction","handleHideNewestAction","handleHideAllAction","tempPromiseResolver","addNotificationToList","numberOfNotifications","implicitStackingLimit","removeNotificationFromList","stepPromises","oldNotifications","slice","shiftNotifications","all","findNotificationById","notificationIndex","findNotificationIndexById","animationOffset","removeAllNotificationsFromList","toMakePlace","notificationPromises","markForCheck","filter","item","find","findIndex","ChangeDetectorRef","NgForOf","notifierCustomConfigFactory","notifierDefaultConfigFactory","NotifierModule","withConfig","ngModule","provide","useValue","deps","useFactory","ɵmod","ɵinj","declarations","exports","imports"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, Inject, EventEmitter, Component, ChangeDetectionStrategy, Input, Output, NgModule } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport * as i4 from '@angular/common';\nimport { CommonModule } from '@angular/common';\n\n/**\n * Notification\n *\n * This class describes the structure of a notifiction, including all information it needs to live, and everyone else needs to work with it.\n */\nclass NotifierNotification {\n    /**\n     * Constructor\n     *\n     * @param options Notifier options\n     */\n    constructor(options) {\n        /**\n         * The template to customize\n         * the appearance of the notification\n         */\n        this.template = null;\n        Object.assign(this, options);\n        // If not set manually, we have to create a unique notification ID by ourselves. The ID generation relies on the current browser\n        // datetime in ms, in praticular the moment this notification gets constructed. Concurrency, and thus two IDs being the exact same,\n        // is not possible due to the action queue concept.\n        if (options.id === undefined) {\n            this.id = `ID_${new Date().getTime()}`;\n        }\n    }\n}\n\n/**\n * Notifier queue service\n *\n * In general, API calls don't get processed right away. Instead, we have to queue them up in order to prevent simultanious API calls\n * interfering with each other. This, at least in theory, is possible at any time. In particular, animations - which potentially overlap -\n * can cause changes in JS classes as well as affect the DOM. Therefore, the queue service takes all actions, puts them in a queue, and\n * processes them at the right time (which is when the previous action has been processed successfully).\n *\n * Technical sidenote:\n * An action looks pretty similar to the ones within the Flux / Redux pattern.\n */\nclass NotifierQueueService {\n    /**\n     * Constructor\n     */\n    constructor() {\n        this.actionStream = new Subject();\n        this.actionQueue = [];\n        this.isActionInProgress = false;\n    }\n    /**\n     * Push a new action to the queue, and try to run it\n     *\n     * @param action Action object\n     */\n    push(action) {\n        this.actionQueue.push(action);\n        this.tryToRunNextAction();\n    }\n    /**\n     * Continue with the next action (called when the current action is finished)\n     */\n    continue() {\n        this.isActionInProgress = false;\n        this.tryToRunNextAction();\n    }\n    /**\n     * Try to run the next action in the queue; we skip if there already is some action in progress, or if there is no action left\n     */\n    tryToRunNextAction() {\n        if (this.isActionInProgress || this.actionQueue.length === 0) {\n            return; // Skip (the queue can now go drink a coffee as it has nothing to do anymore)\n        }\n        this.isActionInProgress = true;\n        this.actionStream.next(this.actionQueue.shift()); // Push next action to the stream, and remove the current action from the queue\n    }\n}\nNotifierQueueService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierQueueService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nNotifierQueueService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierQueueService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierQueueService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return []; } });\n\n/**\n * Injection Token for notifier options\n */\nconst NotifierOptionsToken = new InjectionToken('[angular-notifier] Notifier Options');\n/**\n * Injection Token for notifier configuration\n */\nconst NotifierConfigToken = new InjectionToken('[anuglar-notifier] Notifier Config');\n\n/**\n * Notifier configuration\n *\n * The notifier configuration defines what notifications look like, how they behave, and how they get animated. It is a global\n * configuration, which means that it only can be set once (at the beginning), and cannot be changed afterwards. Aligning to the world of\n * Angular, this configuration can be provided in the root app module - alternatively, a meaningful default configuration will be used.\n */\nclass NotifierConfig {\n    /**\n     * Constructor\n     *\n     * @param [customOptions={}] Custom notifier options, optional\n     */\n    constructor(customOptions = {}) {\n        // Set default values\n        this.animations = {\n            enabled: true,\n            hide: {\n                easing: 'ease',\n                offset: 50,\n                preset: 'fade',\n                speed: 300,\n            },\n            overlap: 150,\n            shift: {\n                easing: 'ease',\n                speed: 300,\n            },\n            show: {\n                easing: 'ease',\n                preset: 'slide',\n                speed: 300,\n            },\n        };\n        this.behaviour = {\n            autoHide: 7000,\n            onClick: false,\n            onMouseover: 'pauseAutoHide',\n            showDismissButton: true,\n            stacking: 4,\n        };\n        this.position = {\n            horizontal: {\n                distance: 12,\n                position: 'left',\n            },\n            vertical: {\n                distance: 12,\n                gap: 10,\n                position: 'bottom',\n            },\n        };\n        this.theme = 'material';\n        // The following merges the custom options into the notifier config, respecting the already set default values\n        // This linear, more explicit and code-sizy workflow is preferred here over a recursive one (because we know the object structure)\n        // Technical sidenote: Objects are merged, other types of values simply overwritten / copied\n        if (customOptions.theme !== undefined) {\n            this.theme = customOptions.theme;\n        }\n        if (customOptions.animations !== undefined) {\n            if (customOptions.animations.enabled !== undefined) {\n                this.animations.enabled = customOptions.animations.enabled;\n            }\n            if (customOptions.animations.overlap !== undefined) {\n                this.animations.overlap = customOptions.animations.overlap;\n            }\n            if (customOptions.animations.hide !== undefined) {\n                Object.assign(this.animations.hide, customOptions.animations.hide);\n            }\n            if (customOptions.animations.shift !== undefined) {\n                Object.assign(this.animations.shift, customOptions.animations.shift);\n            }\n            if (customOptions.animations.show !== undefined) {\n                Object.assign(this.animations.show, customOptions.animations.show);\n            }\n        }\n        if (customOptions.behaviour !== undefined) {\n            Object.assign(this.behaviour, customOptions.behaviour);\n        }\n        if (customOptions.position !== undefined) {\n            if (customOptions.position.horizontal !== undefined) {\n                Object.assign(this.position.horizontal, customOptions.position.horizontal);\n            }\n            if (customOptions.position.vertical !== undefined) {\n                Object.assign(this.position.vertical, customOptions.position.vertical);\n            }\n        }\n    }\n}\n\n/**\n * Notifier service\n *\n * This service provides access to the public notifier API. Once injected into a component, directive, pipe, service, or any other building\n * block of an applications, it can be used to show new notifications, and hide existing ones. Internally, it transforms API calls into\n * actions, which then get thrown into the action queue - eventually being processed at the right moment.\n */\nclass NotifierService {\n    /**\n     * Constructor\n     *\n     * @param notifierQueueService Notifier queue service\n     * @param config               Notifier configuration, optionally injected as a dependency\n     */\n    constructor(notifierQueueService, config) {\n        this.queueService = notifierQueueService;\n        this.config = config;\n    }\n    /**\n     * Get the notifier configuration\n     *\n     * @returns Notifier configuration\n     */\n    getConfig() {\n        return this.config;\n    }\n    /**\n     * Get the observable for handling actions\n     *\n     * @returns Observable of NotifierAction\n     */\n    get actionStream() {\n        return this.queueService.actionStream.asObservable();\n    }\n    /**\n     * API: Show a new notification\n     *\n     * @param notificationOptions Notification options\n     */\n    show(notificationOptions) {\n        this.queueService.push({\n            payload: notificationOptions,\n            type: 'SHOW',\n        });\n    }\n    /**\n     * API: Hide a specific notification, given its ID\n     *\n     * @param notificationId ID of the notification to hide\n     */\n    hide(notificationId) {\n        this.queueService.push({\n            payload: notificationId,\n            type: 'HIDE',\n        });\n    }\n    /**\n     * API: Hide the newest notification\n     */\n    hideNewest() {\n        this.queueService.push({\n            type: 'HIDE_NEWEST',\n        });\n    }\n    /**\n     * API: Hide the oldest notification\n     */\n    hideOldest() {\n        this.queueService.push({\n            type: 'HIDE_OLDEST',\n        });\n    }\n    /**\n     * API: Hide all notifications at once\n     */\n    hideAll() {\n        this.queueService.push({\n            type: 'HIDE_ALL',\n        });\n    }\n    /**\n     * API: Shortcut for showing a new notification\n     *\n     * @param type             Type of the notification\n     * @param message          Message of the notification\n     * @param [notificationId] Unique ID for the notification (optional)\n     */\n    notify(type, message, notificationId) {\n        const notificationOptions = {\n            message,\n            type,\n        };\n        if (notificationId !== undefined) {\n            notificationOptions.id = notificationId;\n        }\n        this.show(notificationOptions);\n    }\n}\nNotifierService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierService, deps: [{ token: NotifierQueueService }, { token: NotifierConfigToken }], target: i0.ɵɵFactoryTarget.Injectable });\nNotifierService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () {\n        return [{ type: NotifierQueueService }, { type: NotifierConfig, decorators: [{\n                        type: Inject,\n                        args: [NotifierConfigToken]\n                    }] }];\n    } });\n\n/**\n * Notifier timer service\n *\n * This service acts as a timer, needed due to the still rather limited setTimeout JavaScript API. The timer service can start and stop a\n * timer. Furthermore, it can also pause the timer at any time, and resume later on. The timer API workd promise-based.\n */\nclass NotifierTimerService {\n    /**\n     * Constructor\n     */\n    constructor() {\n        this.now = 0;\n        this.remaining = 0;\n    }\n    /**\n     * Start (or resume) the timer\n     *\n     * @param   duration Timer duration, in ms\n     * @returns          Promise, resolved once the timer finishes\n     */\n    start(duration) {\n        return new Promise((resolve) => {\n            // For the first run ...\n            this.remaining = duration;\n            // Setup, then start the timer\n            this.finishPromiseResolver = resolve;\n            this.continue();\n        });\n    }\n    /**\n     * Pause the timer\n     */\n    pause() {\n        clearTimeout(this.timerId);\n        this.remaining -= new Date().getTime() - this.now;\n    }\n    /**\n     * Continue the timer\n     */\n    continue() {\n        this.now = new Date().getTime();\n        this.timerId = window.setTimeout(() => {\n            this.finish();\n        }, this.remaining);\n    }\n    /**\n     * Stop the timer\n     */\n    stop() {\n        clearTimeout(this.timerId);\n        this.remaining = 0;\n    }\n    /**\n     * Finish up the timeout by resolving the timer promise\n     */\n    finish() {\n        this.finishPromiseResolver();\n    }\n}\nNotifierTimerService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierTimerService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nNotifierTimerService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierTimerService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierTimerService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return []; } });\n\n/**\n * Fade animation preset\n */\nconst fade = {\n    hide: () => {\n        return {\n            from: {\n                opacity: '1',\n            },\n            to: {\n                opacity: '0',\n            },\n        };\n    },\n    show: () => {\n        return {\n            from: {\n                opacity: '0',\n            },\n            to: {\n                opacity: '1',\n            },\n        };\n    },\n};\n\n/**\n * Slide animation preset\n */\nconst slide = {\n    hide: (notification) => {\n        // Prepare variables\n        const config = notification.component.getConfig();\n        const shift = notification.component.getShift();\n        let from;\n        let to;\n        // Configure variables, depending on configuration and component\n        if (config.position.horizontal.position === 'left') {\n            from = {\n                transform: `translate3d( 0, ${shift}px, 0 )`,\n            };\n            to = {\n                transform: `translate3d( calc( -100% - ${config.position.horizontal.distance}px - 10px ), ${shift}px, 0 )`,\n            };\n        }\n        else if (config.position.horizontal.position === 'right') {\n            from = {\n                transform: `translate3d( 0, ${shift}px, 0 )`,\n            };\n            to = {\n                transform: `translate3d( calc( 100% + ${config.position.horizontal.distance}px + 10px ), ${shift}px, 0 )`,\n            };\n        }\n        else {\n            let horizontalPosition;\n            if (config.position.vertical.position === 'top') {\n                horizontalPosition = `calc( -100% - ${config.position.horizontal.distance}px - 10px )`;\n            }\n            else {\n                horizontalPosition = `calc( 100% + ${config.position.horizontal.distance}px + 10px )`;\n            }\n            from = {\n                transform: `translate3d( -50%, ${shift}px, 0 )`,\n            };\n            to = {\n                transform: `translate3d( -50%, ${horizontalPosition}, 0 )`,\n            };\n        }\n        // Done\n        return {\n            from,\n            to,\n        };\n    },\n    show: (notification) => {\n        // Prepare variables\n        const config = notification.component.getConfig();\n        let from;\n        let to;\n        // Configure variables, depending on configuration and component\n        if (config.position.horizontal.position === 'left') {\n            from = {\n                transform: `translate3d( calc( -100% - ${config.position.horizontal.distance}px - 10px ), 0, 0 )`,\n            };\n            to = {\n                transform: 'translate3d( 0, 0, 0 )',\n            };\n        }\n        else if (config.position.horizontal.position === 'right') {\n            from = {\n                transform: `translate3d( calc( 100% + ${config.position.horizontal.distance}px + 10px ), 0, 0 )`,\n            };\n            to = {\n                transform: 'translate3d( 0, 0, 0 )',\n            };\n        }\n        else {\n            let horizontalPosition;\n            if (config.position.vertical.position === 'top') {\n                horizontalPosition = `calc( -100% - ${config.position.horizontal.distance}px - 10px )`;\n            }\n            else {\n                horizontalPosition = `calc( 100% + ${config.position.horizontal.distance}px + 10px )`;\n            }\n            from = {\n                transform: `translate3d( -50%, ${horizontalPosition}, 0 )`,\n            };\n            to = {\n                transform: 'translate3d( -50%, 0, 0 )',\n            };\n        }\n        // Done\n        return {\n            from,\n            to,\n        };\n    },\n};\n\n/**\n * Notifier animation service\n */\nclass NotifierAnimationService {\n    /**\n     * Constructor\n     */\n    constructor() {\n        this.animationPresets = {\n            fade,\n            slide,\n        };\n    }\n    /**\n     * Get animation data\n     *\n     * This method generates all data the Web Animations API needs to animate our notification. The result depends on both the animation\n     * direction (either in or out) as well as the notifications (and its attributes) itself.\n     *\n     * @param   direction    Animation direction, either in or out\n     * @param   notification Notification the animation data should be generated for\n     * @returns Animation information\n     */\n    getAnimationData(direction, notification) {\n        // Get all necessary animation data\n        let keyframes;\n        let duration;\n        let easing;\n        if (direction === 'show') {\n            keyframes = this.animationPresets[notification.component.getConfig().animations.show.preset].show(notification);\n            duration = notification.component.getConfig().animations.show.speed;\n            easing = notification.component.getConfig().animations.show.easing;\n        }\n        else {\n            keyframes = this.animationPresets[notification.component.getConfig().animations.hide.preset].hide(notification);\n            duration = notification.component.getConfig().animations.hide.speed;\n            easing = notification.component.getConfig().animations.hide.easing;\n        }\n        // Build and return animation data\n        return {\n            keyframes: [keyframes.from, keyframes.to],\n            options: {\n                duration,\n                easing,\n                fill: 'forwards', // Keep the newly painted state after the animation finished\n            },\n        };\n    }\n}\nNotifierAnimationService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierAnimationService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nNotifierAnimationService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierAnimationService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierAnimationService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return []; } });\n\n/**\n * Notifier notification component\n * -------------------------------\n * This component is responsible for actually displaying the notification on screen. In addition, it's able to show and hide this\n * notification, in particular to animate this notification in and out, as well as shift (move) this notification vertically around.\n * Furthermore, the notification component handles all interactions the user has with this notification / component, such as clicks and\n * mouse movements.\n */\nclass NotifierNotificationComponent {\n    /**\n     * Constructor\n     *\n     * @param elementRef               Reference to the component's element\n     * @param renderer                 Angular renderer\n     * @param notifierService          Notifier service\n     * @param notifierTimerService     Notifier timer service\n     * @param notifierAnimationService Notifier animation service\n     */\n    constructor(elementRef, renderer, notifierService, notifierTimerService, notifierAnimationService) {\n        this.config = notifierService.getConfig();\n        this.ready = new EventEmitter();\n        this.dismiss = new EventEmitter();\n        this.timerService = notifierTimerService;\n        this.animationService = notifierAnimationService;\n        this.renderer = renderer;\n        this.element = elementRef.nativeElement;\n        this.elementShift = 0;\n    }\n    /**\n     * Component after view init lifecycle hook, setts up the component and then emits the ready event\n     */\n    ngAfterViewInit() {\n        this.setup();\n        this.elementHeight = this.element.offsetHeight;\n        this.elementWidth = this.element.offsetWidth;\n        this.ready.emit(this);\n    }\n    /**\n     * Get the notifier config\n     *\n     * @returns Notifier configuration\n     */\n    getConfig() {\n        return this.config;\n    }\n    /**\n     * Get notification element height (in px)\n     *\n     * @returns Notification element height (in px)\n     */\n    getHeight() {\n        return this.elementHeight;\n    }\n    /**\n     * Get notification element width (in px)\n     *\n     * @returns Notification element height (in px)\n     */\n    getWidth() {\n        return this.elementWidth;\n    }\n    /**\n     * Get notification shift offset (in px)\n     *\n     * @returns Notification element shift offset (in px)\n     */\n    getShift() {\n        return this.elementShift;\n    }\n    /**\n     * Show (animate in) this notification\n     *\n     * @returns Promise, resolved when done\n     */\n    show() {\n        return new Promise((resolve) => {\n            // Are animations enabled?\n            if (this.config.animations.enabled && this.config.animations.show.speed > 0) {\n                // Get animation data\n                const animationData = this.animationService.getAnimationData('show', this.notification);\n                // Set initial styles (styles before animation), prevents quick flicker when animation starts\n                const animatedProperties = Object.keys(animationData.keyframes[0]);\n                for (let i = animatedProperties.length - 1; i >= 0; i--) {\n                    this.renderer.setStyle(this.element, animatedProperties[i], animationData.keyframes[0][animatedProperties[i]]);\n                }\n                // Animate notification in\n                this.renderer.setStyle(this.element, 'visibility', 'visible');\n                const animation = this.element.animate(animationData.keyframes, animationData.options);\n                animation.onfinish = () => {\n                    this.startAutoHideTimer();\n                    resolve(); // Done\n                };\n            }\n            else {\n                // Show notification\n                this.renderer.setStyle(this.element, 'visibility', 'visible');\n                this.startAutoHideTimer();\n                resolve(); // Done\n            }\n        });\n    }\n    /**\n     * Hide (animate out) this notification\n     *\n     * @returns Promise, resolved when done\n     */\n    hide() {\n        return new Promise((resolve) => {\n            this.stopAutoHideTimer();\n            // Are animations enabled?\n            if (this.config.animations.enabled && this.config.animations.hide.speed > 0) {\n                const animationData = this.animationService.getAnimationData('hide', this.notification);\n                const animation = this.element.animate(animationData.keyframes, animationData.options);\n                animation.onfinish = () => {\n                    resolve(); // Done\n                };\n            }\n            else {\n                resolve(); // Done\n            }\n        });\n    }\n    /**\n     * Shift (move) this notification\n     *\n     * @param   distance         Distance to shift (in px)\n     * @param   shiftToMakePlace Flag, defining in which direction to shift\n     * @returns Promise, resolved when done\n     */\n    shift(distance, shiftToMakePlace) {\n        return new Promise((resolve) => {\n            // Calculate new position (position after the shift)\n            let newElementShift;\n            if ((this.config.position.vertical.position === 'top' && shiftToMakePlace) ||\n                (this.config.position.vertical.position === 'bottom' && !shiftToMakePlace)) {\n                newElementShift = this.elementShift + distance + this.config.position.vertical.gap;\n            }\n            else {\n                newElementShift = this.elementShift - distance - this.config.position.vertical.gap;\n            }\n            const horizontalPosition = this.config.position.horizontal.position === 'middle' ? '-50%' : '0';\n            // Are animations enabled?\n            if (this.config.animations.enabled && this.config.animations.shift.speed > 0) {\n                const animationData = {\n                    // TODO: Extract into animation service\n                    keyframes: [\n                        {\n                            transform: `translate3d( ${horizontalPosition}, ${this.elementShift}px, 0 )`,\n                        },\n                        {\n                            transform: `translate3d( ${horizontalPosition}, ${newElementShift}px, 0 )`,\n                        },\n                    ],\n                    options: {\n                        duration: this.config.animations.shift.speed,\n                        easing: this.config.animations.shift.easing,\n                        fill: 'forwards',\n                    },\n                };\n                this.elementShift = newElementShift;\n                const animation = this.element.animate(animationData.keyframes, animationData.options);\n                animation.onfinish = () => {\n                    resolve(); // Done\n                };\n            }\n            else {\n                this.renderer.setStyle(this.element, 'transform', `translate3d( ${horizontalPosition}, ${newElementShift}px, 0 )`);\n                this.elementShift = newElementShift;\n                resolve(); // Done\n            }\n        });\n    }\n    /**\n     * Handle click on dismiss button\n     */\n    onClickDismiss() {\n        this.dismiss.emit(this.notification.id);\n    }\n    /**\n     * Handle mouseover over notification area\n     */\n    onNotificationMouseover() {\n        if (this.config.behaviour.onMouseover === 'pauseAutoHide') {\n            this.pauseAutoHideTimer();\n        }\n        else if (this.config.behaviour.onMouseover === 'resetAutoHide') {\n            this.stopAutoHideTimer();\n        }\n    }\n    /**\n     * Handle mouseout from notification area\n     */\n    onNotificationMouseout() {\n        if (this.config.behaviour.onMouseover === 'pauseAutoHide') {\n            this.continueAutoHideTimer();\n        }\n        else if (this.config.behaviour.onMouseover === 'resetAutoHide') {\n            this.startAutoHideTimer();\n        }\n    }\n    /**\n     * Handle click on notification area\n     */\n    onNotificationClick() {\n        if (this.config.behaviour.onClick === 'hide') {\n            this.onClickDismiss();\n        }\n    }\n    /**\n     * Start the auto hide timer (if enabled)\n     */\n    startAutoHideTimer() {\n        if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n            this.timerService.start(this.config.behaviour.autoHide).then(() => {\n                this.onClickDismiss();\n            });\n        }\n    }\n    /**\n     * Pause the auto hide timer (if enabled)\n     */\n    pauseAutoHideTimer() {\n        if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n            this.timerService.pause();\n        }\n    }\n    /**\n     * Continue the auto hide timer (if enabled)\n     */\n    continueAutoHideTimer() {\n        if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n            this.timerService.continue();\n        }\n    }\n    /**\n     * Stop the auto hide timer (if enabled)\n     */\n    stopAutoHideTimer() {\n        if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n            this.timerService.stop();\n        }\n    }\n    /**\n     * Initial notification setup\n     */\n    setup() {\n        // Set start position (initially the exact same for every new notification)\n        if (this.config.position.horizontal.position === 'left') {\n            this.renderer.setStyle(this.element, 'left', `${this.config.position.horizontal.distance}px`);\n        }\n        else if (this.config.position.horizontal.position === 'right') {\n            this.renderer.setStyle(this.element, 'right', `${this.config.position.horizontal.distance}px`);\n        }\n        else {\n            this.renderer.setStyle(this.element, 'left', '50%');\n            // Let's get the GPU handle some work as well (#perfmatters)\n            this.renderer.setStyle(this.element, 'transform', 'translate3d( -50%, 0, 0 )');\n        }\n        if (this.config.position.vertical.position === 'top') {\n            this.renderer.setStyle(this.element, 'top', `${this.config.position.vertical.distance}px`);\n        }\n        else {\n            this.renderer.setStyle(this.element, 'bottom', `${this.config.position.vertical.distance}px`);\n        }\n        // Add classes (responsible for visual design)\n        this.renderer.addClass(this.element, `notifier__notification--${this.notification.type}`);\n        this.renderer.addClass(this.element, `notifier__notification--${this.config.theme}`);\n    }\n}\nNotifierNotificationComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierNotificationComponent, deps: [{ token: i0.ElementRef }, { token: i0.Renderer2 }, { token: NotifierService }, { token: NotifierTimerService }, { token: NotifierAnimationService }], target: i0.ɵɵFactoryTarget.Component });\nNotifierNotificationComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.2.3\", type: NotifierNotificationComponent, selector: \"notifier-notification\", inputs: { notification: \"notification\" }, outputs: { ready: \"ready\", dismiss: \"dismiss\" }, host: { listeners: { \"click\": \"onNotificationClick()\", \"mouseout\": \"onNotificationMouseout()\", \"mouseover\": \"onNotificationMouseover()\" }, classAttribute: \"notifier__notification\" }, providers: [\n        // We provide the timer to the component's local injector, so that every notification components gets its own\n        // instance of the timer service, thus running their timers independently from each other\n        NotifierTimerService,\n    ], ngImport: i0, template: \"<ng-container\\n  *ngIf=\\\"notification.template; else predefinedNotification\\\"\\n  [ngTemplateOutlet]=\\\"notification.template\\\"\\n  [ngTemplateOutletContext]=\\\"{ notification: notification }\\\"\\n>\\n</ng-container>\\n\\n<ng-template #predefinedNotification>\\n  <p class=\\\"notifier__notification-message\\\">{{ notification.message }}</p>\\n  <button\\n    class=\\\"notifier__notification-button\\\"\\n    type=\\\"button\\\"\\n    title=\\\"dismiss\\\"\\n    *ngIf=\\\"config.behaviour.showDismissButton\\\"\\n    (click)=\\\"onClickDismiss()\\\"\\n  >\\n    <svg class=\\\"notifier__notification-button-icon\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"20\\\" height=\\\"20\\\">\\n      <path d=\\\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\\\" />\\n    </svg>\\n  </button>\\n</ng-template>\\n\", directives: [{ type: i4.NgIf, selector: \"[ngIf]\", inputs: [\"ngIf\", \"ngIfThen\", \"ngIfElse\"] }, { type: i4.NgTemplateOutlet, selector: \"[ngTemplateOutlet]\", inputs: [\"ngTemplateOutletContext\", \"ngTemplateOutlet\"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierNotificationComponent, decorators: [{\n            type: Component,\n            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, host: {\n                        '(click)': 'onNotificationClick()',\n                        '(mouseout)': 'onNotificationMouseout()',\n                        '(mouseover)': 'onNotificationMouseover()',\n                        class: 'notifier__notification',\n                    }, providers: [\n                        // We provide the timer to the component's local injector, so that every notification components gets its own\n                        // instance of the timer service, thus running their timers independently from each other\n                        NotifierTimerService,\n                    ], selector: 'notifier-notification', template: \"<ng-container\\n  *ngIf=\\\"notification.template; else predefinedNotification\\\"\\n  [ngTemplateOutlet]=\\\"notification.template\\\"\\n  [ngTemplateOutletContext]=\\\"{ notification: notification }\\\"\\n>\\n</ng-container>\\n\\n<ng-template #predefinedNotification>\\n  <p class=\\\"notifier__notification-message\\\">{{ notification.message }}</p>\\n  <button\\n    class=\\\"notifier__notification-button\\\"\\n    type=\\\"button\\\"\\n    title=\\\"dismiss\\\"\\n    *ngIf=\\\"config.behaviour.showDismissButton\\\"\\n    (click)=\\\"onClickDismiss()\\\"\\n  >\\n    <svg class=\\\"notifier__notification-button-icon\\\" viewBox=\\\"0 0 24 24\\\" width=\\\"20\\\" height=\\\"20\\\">\\n      <path d=\\\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z\\\" />\\n    </svg>\\n  </button>\\n</ng-template>\\n\" }]\n        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i0.Renderer2 }, { type: NotifierService }, { type: NotifierTimerService }, { type: NotifierAnimationService }]; }, propDecorators: { notification: [{\n                type: Input\n            }], ready: [{\n                type: Output\n            }], dismiss: [{\n                type: Output\n            }] } });\n\n/**\n * Notifier container component\n * ----------------------------\n * This component acts as a wrapper for all notification components; consequently, it is responsible for creating a new notification\n * component and removing an existing notification component. Being more precicely, it also handles side effects of those actions, such as\n * shifting or even completely removing other notifications as well. Overall, this components handles actions coming from the queue service\n * by subscribing to its action stream.\n *\n * Technical sidenote:\n * This component has to be used somewhere in an application to work; it will not inject and create itself automatically, primarily in order\n * to not break the Angular AoT compilation. Moreover, this component (and also the notification components) set their change detection\n * strategy onPush, which means that we handle change detection manually in order to get the best performance. (#perfmatters)\n */\nclass NotifierContainerComponent {\n    /**\n     * Constructor\n     *\n     * @param changeDetector       Change detector, used for manually triggering change detection runs\n     * @param notifierQueueService Notifier queue service\n     * @param notifierService      Notifier service\n     */\n    constructor(changeDetector, notifierQueueService, notifierService) {\n        this.changeDetector = changeDetector;\n        this.queueService = notifierQueueService;\n        this.config = notifierService.getConfig();\n        this.notifications = [];\n        // Connects this component up to the action queue, then handle incoming actions\n        this.queueServiceSubscription = this.queueService.actionStream.subscribe((action) => {\n            this.handleAction(action).then(() => {\n                this.queueService.continue();\n            });\n        });\n    }\n    /**\n     * Component destroyment lifecycle hook, cleans up the observable subsciption\n     */\n    ngOnDestroy() {\n        if (this.queueServiceSubscription) {\n            this.queueServiceSubscription.unsubscribe();\n        }\n    }\n    /**\n     * Notification identifier, used as the ngFor trackby function\n     *\n     * @param   index        Index\n     * @param   notification Notifier notification\n     * @returns Notification ID as the unique identnfier\n     */\n    identifyNotification(index, notification) {\n        return notification.id;\n    }\n    /**\n     * Event handler, handles clicks on notification dismiss buttons\n     *\n     * @param notificationId ID of the notification to dismiss\n     */\n    onNotificationDismiss(notificationId) {\n        this.queueService.push({\n            payload: notificationId,\n            type: 'HIDE',\n        });\n    }\n    /**\n     * Event handler, handles notification ready events\n     *\n     * @param notificationComponent Notification component reference\n     */\n    onNotificationReady(notificationComponent) {\n        const currentNotification = this.notifications[this.notifications.length - 1]; // Get the latest notification\n        currentNotification.component = notificationComponent; // Save the new omponent reference\n        this.continueHandleShowAction(currentNotification); // Continue with handling the show action\n    }\n    /**\n     * Handle incoming actions by mapping action types to methods, and then running them\n     *\n     * @param   action Action object\n     * @returns Promise, resolved when done\n     */\n    handleAction(action) {\n        switch (action.type // TODO: Maybe a map (actionType -> class method) is a cleaner solution here?\n        ) {\n            case 'SHOW':\n                return this.handleShowAction(action);\n            case 'HIDE':\n                return this.handleHideAction(action);\n            case 'HIDE_OLDEST':\n                return this.handleHideOldestAction(action);\n            case 'HIDE_NEWEST':\n                return this.handleHideNewestAction(action);\n            case 'HIDE_ALL':\n                return this.handleHideAllAction();\n            default:\n                return new Promise((resolve) => {\n                    resolve(); // Ignore unknown action types\n                });\n        }\n    }\n    /**\n     * Show a new notification\n     *\n     * We simply add the notification to the list, and then wait until its properly initialized / created / rendered.\n     *\n     * @param   action Action object\n     * @returns Promise, resolved when done\n     */\n    handleShowAction(action) {\n        return new Promise((resolve) => {\n            this.tempPromiseResolver = resolve; // Save the promise resolve function so that it can be called later on by another method\n            this.addNotificationToList(new NotifierNotification(action.payload));\n        });\n    }\n    /**\n     * Continue to show a new notification (after the notification components is initialized / created / rendered).\n     *\n     * If this is the first (and thus only) notification, we can simply show it. Otherwhise, if stacking is disabled (or a low value), we\n     * switch out notifications, in particular we hide the existing one, and then show our new one. Yet, if stacking is enabled, we first\n     * shift all older notifications, and then show our new notification. In addition, if there are too many notification on the screen,\n     * we hide the oldest one first. Furthermore, if configured, animation overlapping is applied.\n     *\n     * @param notification New notification to show\n     */\n    continueHandleShowAction(notification) {\n        // First (which means only one) notification in the list?\n        const numberOfNotifications = this.notifications.length;\n        if (numberOfNotifications === 1) {\n            notification.component.show().then(this.tempPromiseResolver); // Done\n        }\n        else {\n            const implicitStackingLimit = 2;\n            // Stacking enabled? (stacking value below 2 means stacking is disabled)\n            if (this.config.behaviour.stacking === false || this.config.behaviour.stacking < implicitStackingLimit) {\n                this.notifications[0].component.hide().then(() => {\n                    this.removeNotificationFromList(this.notifications[0]);\n                    notification.component.show().then(this.tempPromiseResolver); // Done\n                });\n            }\n            else {\n                const stepPromises = [];\n                // Are there now too many notifications?\n                if (numberOfNotifications > this.config.behaviour.stacking) {\n                    const oldNotifications = this.notifications.slice(1, numberOfNotifications - 1);\n                    // Are animations enabled?\n                    if (this.config.animations.enabled) {\n                        // Is animation overlap enabled?\n                        if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                            stepPromises.push(this.notifications[0].component.hide());\n                            setTimeout(() => {\n                                stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                            }, this.config.animations.hide.speed - this.config.animations.overlap);\n                            setTimeout(() => {\n                                stepPromises.push(notification.component.show());\n                            }, this.config.animations.hide.speed + this.config.animations.shift.speed - this.config.animations.overlap);\n                        }\n                        else {\n                            stepPromises.push(new Promise((resolve) => {\n                                this.notifications[0].component.hide().then(() => {\n                                    this.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(() => {\n                                        notification.component.show().then(resolve);\n                                    });\n                                });\n                            }));\n                        }\n                    }\n                    else {\n                        stepPromises.push(this.notifications[0].component.hide());\n                        stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                        stepPromises.push(notification.component.show());\n                    }\n                }\n                else {\n                    const oldNotifications = this.notifications.slice(0, numberOfNotifications - 1);\n                    // Are animations enabled?\n                    if (this.config.animations.enabled) {\n                        // Is animation overlap enabled?\n                        if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                            setTimeout(() => {\n                                stepPromises.push(notification.component.show());\n                            }, this.config.animations.shift.speed - this.config.animations.overlap);\n                        }\n                        else {\n                            stepPromises.push(new Promise((resolve) => {\n                                this.shiftNotifications(oldNotifications, notification.component.getHeight(), true).then(() => {\n                                    notification.component.show().then(resolve);\n                                });\n                            }));\n                        }\n                    }\n                    else {\n                        stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), true));\n                        stepPromises.push(notification.component.show());\n                    }\n                }\n                Promise.all(stepPromises).then(() => {\n                    if (numberOfNotifications > this.config.behaviour.stacking) {\n                        this.removeNotificationFromList(this.notifications[0]);\n                    }\n                    this.tempPromiseResolver();\n                }); // Done\n            }\n        }\n    }\n    /**\n     * Hide an existing notification\n     *\n     * Fist, we skip everything if there are no notifications at all, or the given notification does not exist. Then, we hide the given\n     * notification. If there exist older notifications, we then shift them around to fill the gap. Once both hiding the given notification\n     * and shifting the older notificaitons is done, the given notification gets finally removed (from the DOM).\n     *\n     * @param   action Action object, payload contains the notification ID\n     * @returns Promise, resolved when done\n     */\n    handleHideAction(action) {\n        return new Promise((resolve) => {\n            const stepPromises = [];\n            // Does the notification exist / are there even any notifications? (let's prevent accidential errors)\n            const notification = this.findNotificationById(action.payload);\n            if (notification === undefined) {\n                resolve();\n                return;\n            }\n            // Get older notifications\n            const notificationIndex = this.findNotificationIndexById(action.payload);\n            if (notificationIndex === undefined) {\n                resolve();\n                return;\n            }\n            const oldNotifications = this.notifications.slice(0, notificationIndex);\n            // Do older notifications exist, and thus do we need to shift other notifications as a consequence?\n            if (oldNotifications.length > 0) {\n                // Are animations enabled?\n                if (this.config.animations.enabled && this.config.animations.hide.speed > 0) {\n                    // Is animation overlap enabled?\n                    if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                        stepPromises.push(notification.component.hide());\n                        setTimeout(() => {\n                            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n                        }, this.config.animations.hide.speed - this.config.animations.overlap);\n                    }\n                    else {\n                        notification.component.hide().then(() => {\n                            stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n                        });\n                    }\n                }\n                else {\n                    stepPromises.push(notification.component.hide());\n                    stepPromises.push(this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n                }\n            }\n            else {\n                stepPromises.push(notification.component.hide());\n            }\n            // Wait until both hiding and shifting is done, then remove the notification from the list\n            Promise.all(stepPromises).then(() => {\n                this.removeNotificationFromList(notification);\n                resolve(); // Done\n            });\n        });\n    }\n    /**\n     * Hide the oldest notification (bridge to handleHideAction)\n     *\n     * @param   action Action object\n     * @returns Promise, resolved when done\n     */\n    handleHideOldestAction(action) {\n        // Are there any notifications? (prevent accidential errors)\n        if (this.notifications.length === 0) {\n            return new Promise((resolve) => {\n                resolve();\n            }); // Done\n        }\n        else {\n            action.payload = this.notifications[0].id;\n            return this.handleHideAction(action);\n        }\n    }\n    /**\n     * Hide the newest notification (bridge to handleHideAction)\n     *\n     * @param   action Action object\n     * @returns Promise, resolved when done\n     */\n    handleHideNewestAction(action) {\n        // Are there any notifications? (prevent accidential errors)\n        if (this.notifications.length === 0) {\n            return new Promise((resolve) => {\n                resolve();\n            }); // Done\n        }\n        else {\n            action.payload = this.notifications[this.notifications.length - 1].id;\n            return this.handleHideAction(action);\n        }\n    }\n    /**\n     * Hide all notifications at once\n     *\n     * @returns Promise, resolved when done\n     */\n    handleHideAllAction() {\n        return new Promise((resolve) => {\n            // Are there any notifications? (prevent accidential errors)\n            const numberOfNotifications = this.notifications.length;\n            if (numberOfNotifications === 0) {\n                resolve(); // Done\n                return;\n            }\n            // Are animations enabled?\n            if (this.config.animations.enabled &&\n                this.config.animations.hide.speed > 0 &&\n                this.config.animations.hide.offset !== false &&\n                this.config.animations.hide.offset > 0) {\n                for (let i = numberOfNotifications - 1; i >= 0; i--) {\n                    const animationOffset = this.config.position.vertical.position === 'top' ? numberOfNotifications - 1 : i;\n                    setTimeout(() => {\n                        this.notifications[i].component.hide().then(() => {\n                            // Are we done here, was this the last notification to be hidden?\n                            if ((this.config.position.vertical.position === 'top' && i === 0) ||\n                                (this.config.position.vertical.position === 'bottom' && i === numberOfNotifications - 1)) {\n                                this.removeAllNotificationsFromList();\n                                resolve(); // Done\n                            }\n                        });\n                    }, this.config.animations.hide.offset * animationOffset);\n                }\n            }\n            else {\n                const stepPromises = [];\n                for (let i = numberOfNotifications - 1; i >= 0; i--) {\n                    stepPromises.push(this.notifications[i].component.hide());\n                }\n                Promise.all(stepPromises).then(() => {\n                    this.removeAllNotificationsFromList();\n                    resolve(); // Done\n                });\n            }\n        });\n    }\n    /**\n     * Shift multiple notifications at once\n     *\n     * @param   notifications List containing the notifications to be shifted\n     * @param   distance      Distance to shift (in px)\n     * @param   toMakePlace   Flag, defining in which direciton to shift\n     * @returns Promise, resolved when done\n     */\n    shiftNotifications(notifications, distance, toMakePlace) {\n        return new Promise((resolve) => {\n            // Are there any notifications to shift?\n            if (notifications.length === 0) {\n                resolve();\n                return;\n            }\n            const notificationPromises = [];\n            for (let i = notifications.length - 1; i >= 0; i--) {\n                notificationPromises.push(notifications[i].component.shift(distance, toMakePlace));\n            }\n            Promise.all(notificationPromises).then(resolve); // Done\n        });\n    }\n    /**\n     * Add a new notification to the list of notifications (triggers change detection)\n     *\n     * @param notification Notification to add to the list of notifications\n     */\n    addNotificationToList(notification) {\n        this.notifications.push(notification);\n        this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n    /**\n     * Remove an existing notification from the list of notifications (triggers change detection)\n     *\n     * @param notification Notification to be removed from the list of notifications\n     */\n    removeNotificationFromList(notification) {\n        this.notifications = this.notifications.filter((item) => item.component !== notification.component);\n        this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n    /**\n     * Remove all notifications from the list (triggers change detection)\n     */\n    removeAllNotificationsFromList() {\n        this.notifications = [];\n        this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n    }\n    /**\n     * Helper: Find a notification in the notification list by a given notification ID\n     *\n     * @param   notificationId Notification ID, used for finding notification\n     * @returns Notification, undefined if not found\n     */\n    findNotificationById(notificationId) {\n        return this.notifications.find((currentNotification) => currentNotification.id === notificationId);\n    }\n    /**\n     * Helper: Find a notification's index by a given notification ID\n     *\n     * @param   notificationId Notification ID, used for finding a notification's index\n     * @returns Notification index, undefined if not found\n     */\n    findNotificationIndexById(notificationId) {\n        const notificationIndex = this.notifications.findIndex((currentNotification) => currentNotification.id === notificationId);\n        return notificationIndex !== -1 ? notificationIndex : undefined;\n    }\n}\nNotifierContainerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierContainerComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: NotifierQueueService }, { token: NotifierService }], target: i0.ɵɵFactoryTarget.Component });\nNotifierContainerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: \"12.0.0\", version: \"13.2.3\", type: NotifierContainerComponent, selector: \"notifier-container\", host: { classAttribute: \"notifier__container\" }, ngImport: i0, template: \"<ul class=\\\"notifier__container-list\\\">\\n  <li class=\\\"notifier__container-list-item\\\" *ngFor=\\\"let notification of notifications; trackBy: identifyNotification\\\">\\n    <notifier-notification [notification]=\\\"notification\\\" (ready)=\\\"onNotificationReady($event)\\\" (dismiss)=\\\"onNotificationDismiss($event)\\\">\\n    </notifier-notification>\\n  </li>\\n</ul>\\n\", components: [{ type: NotifierNotificationComponent, selector: \"notifier-notification\", inputs: [\"notification\"], outputs: [\"ready\", \"dismiss\"] }], directives: [{ type: i4.NgForOf, selector: \"[ngFor][ngForOf]\", inputs: [\"ngForOf\", \"ngForTrackBy\", \"ngForTemplate\"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierContainerComponent, decorators: [{\n            type: Component,\n            args: [{ changeDetection: ChangeDetectionStrategy.OnPush, host: {\n                        class: 'notifier__container',\n                    }, selector: 'notifier-container', template: \"<ul class=\\\"notifier__container-list\\\">\\n  <li class=\\\"notifier__container-list-item\\\" *ngFor=\\\"let notification of notifications; trackBy: identifyNotification\\\">\\n    <notifier-notification [notification]=\\\"notification\\\" (ready)=\\\"onNotificationReady($event)\\\" (dismiss)=\\\"onNotificationDismiss($event)\\\">\\n    </notifier-notification>\\n  </li>\\n</ul>\\n\" }]\n        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: NotifierQueueService }, { type: NotifierService }]; } });\n\n/**\n * Factory for a notifier configuration with custom options\n *\n * Sidenote:\n * Required as Angular AoT compilation cannot handle dynamic functions; see <https://github.com/angular/angular/issues/11262>.\n *\n * @param   options - Custom notifier options\n * @returns - Notifier configuration as result\n */\nfunction notifierCustomConfigFactory(options) {\n    return new NotifierConfig(options);\n}\n/**\n * Factory for a notifier configuration with default options\n *\n * Sidenote:\n * Required as Angular AoT compilation cannot handle dynamic functions; see <https://github.com/angular/angular/issues/11262>.\n *\n * @returns - Notifier configuration as result\n */\nfunction notifierDefaultConfigFactory() {\n    return new NotifierConfig({});\n}\n/**\n * Notifier module\n */\nclass NotifierModule {\n    /**\n     * Setup the notifier module with custom providers, in this case with a custom configuration based on the givne options\n     *\n     * @param   [options={}] - Custom notifier options\n     * @returns - Notifier module with custom providers\n     */\n    static withConfig(options = {}) {\n        return {\n            ngModule: NotifierModule,\n            providers: [\n                // Provide the options itself upfront (as we need to inject them as dependencies -- see below)\n                {\n                    provide: NotifierOptionsToken,\n                    useValue: options,\n                },\n                // Provide a custom notifier configuration, based on the given notifier options\n                {\n                    deps: [NotifierOptionsToken],\n                    provide: NotifierConfigToken,\n                    useFactory: notifierCustomConfigFactory,\n                },\n            ],\n        };\n    }\n}\nNotifierModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nNotifierModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierModule, declarations: [NotifierContainerComponent, NotifierNotificationComponent], imports: [CommonModule], exports: [NotifierContainerComponent] });\nNotifierModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierModule, providers: [\n        NotifierAnimationService,\n        NotifierService,\n        NotifierQueueService,\n        // Provide the default notifier configuration if just the module is imported\n        {\n            provide: NotifierConfigToken,\n            useFactory: notifierDefaultConfigFactory,\n        },\n    ], imports: [[CommonModule]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.2.3\", ngImport: i0, type: NotifierModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    declarations: [NotifierContainerComponent, NotifierNotificationComponent],\n                    exports: [NotifierContainerComponent],\n                    imports: [CommonModule],\n                    providers: [\n                        NotifierAnimationService,\n                        NotifierService,\n                        NotifierQueueService,\n                        // Provide the default notifier configuration if just the module is imported\n                        {\n                            provide: NotifierConfigToken,\n                            useFactory: notifierDefaultConfigFactory,\n                        },\n                    ],\n                }]\n        }] });\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NotifierConfig, NotifierConfigToken, NotifierContainerComponent, NotifierModule, NotifierNotificationComponent, NotifierOptionsToken, NotifierService, notifierCustomConfigFactory, notifierDefaultConfigFactory };\n"]},"metadata":{},"sourceType":"module"}